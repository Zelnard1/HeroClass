// Function to serve HTML for the web app
function doGet() {
  // Load Wheel of Destiny Data
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Wheel of Destiny Data');
  const data = sheet.getRange('A2:B19').getValues(); // Fetch data for the Wheel

  // Map data into a usable format
  const imageData = data.map(row => ({
    number: row[0],
    url: row[1],
  }));

  // Embed data into the player dashboard
  const template = HtmlService.createTemplateFromFile('Index');
  template.imageData = JSON.stringify(imageData); // Pass image data to the frontend
  return template.evaluate()
    .setTitle('Player Dashboard')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}



// Global variables for logging
var LOG_SHEET_NAME = "GameFeed";
var PET_IMAGE_SHEET_NAME = "Pet Lookup";
var PET_IMAGE_CYCLE_START = 2;
var PET_IMAGE_CYCLE_END = 15;
var DAILY_CRYSTAL_CAPS = {
  Healer: 5,
  Guardian: 4,
  Mage: 6
};

// Main onEdit function for handling sheet edits
function onEdit(e) {
    const sheet = e.source.getActiveSheet();
    const editedCell = e.range;

    const maxValues = {
        Healer: { health: 8, crystals: 5 },
        Mage: { health: 6, crystals: 6 },
        Guardian: { health: 10, crystals: 4 }
    };

    // Handle edits in the "XP, Mana, Health" sheet
    if (sheet.getName() === "XP, Mana, Health") {
        const inputToTotalMap = { 9: 5, 10: 6, 11: 7, 12: 8 }; // IJKL -> EFGH
        const row = editedCell.getRow();
        const col = editedCell.getColumn();

        console.log(`onEdit triggered: Sheet: XP, Mana, Health | Row: ${row} | Column: ${col}`);

        // Process input values and apply maximum limits
        if (inputToTotalMap[col]) {
            const totalCol = inputToTotalMap[col];
            const inputValue = editedCell.getValue();

            console.log(`Processing input: Row ${row}, Column ${col}, Value: ${inputValue}`);

            if (inputValue && !isNaN(inputValue)) {
                const currentTotal = sheet.getRange(row, totalCol).getValue() || 0;
                let newTotal = currentTotal + inputValue;

                const playerClass = sheet.getRange(row, 2).getValue();
                if (totalCol === 6) newTotal = Math.min(newTotal, maxValues[playerClass]?.health || newTotal); // Health
                if (totalCol === 7) newTotal = Math.min(newTotal, maxValues[playerClass]?.crystals || newTotal); // Crystals

                sheet.getRange(row, totalCol).setValue(newTotal);
                sheet.getRange(row, col).setValue(""); // Clear input cell

                console.log(`Updated totals: Row ${row}, Column ${totalCol}, New Total: ${newTotal}`);
                
                // Trigger level update for XP column (E) after updating it
                if (totalCol === 5) {
                    console.log(`Recalculating levels due to updated XP in Column E for Row ${row}`);
                    updatePlayerLevels();
                }

                // Log manual entries
                const playerName = sheet.getRange(row, 1).getValue();
                const statType = col === 9 ? "XP" : col === 10 ? "Health" : col === 11 ? "Crystals" : "GP";
                logGameAction(playerName, statType, inputValue, "Manual Entry");
            }
        }

        // Trigger level update when XP column (E) is updated
        if (col === 5) {
            console.log(`XP updated in Column E for Row ${row}`);
            updatePlayerLevels();
        }
    }
    // Handle edits in the "GameFeed" sheet for tickertape updates
    if (sheet.getName() === "GameFeed") {
        console.log(`onEdit triggered: Sheet: GameFeed | Broadcasting tickertape update.`);
        const latestEntries = getLatestGameFeedEntries();
        broadcastTickertapeUpdate(latestEntries);
    }

    // Handle edits in the "Teams" sheet
    if (sheet.getName() === "Teams") {
        const row = editedCell.getRow();
        const col = editedCell.getColumn();
        const addedValue = editedCell.getValue();
        const playerName = sheet.getRange(row, 2).getValue();

        console.log(`onEdit triggered: Sheet: Teams | Row: ${row} | Column: ${col} | Value: ${addedValue}`);

        if (addedValue && !isNaN(addedValue)) {
            const xpSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
            const playerNames = xpSheet.getRange("A2:A100").getValues();

            for (let i = 0; i < playerNames.length; i++) {
                if (playerNames[i][0] === playerName) {
                    let targetCol, statType;

                    if (col === 10) { targetCol = 5; statType = "XP"; }
                    else if (col === 11) { targetCol = 6; statType = "Health"; }
                    else if (col === 12) { targetCol = 7; statType = "Crystals"; }
                    else if (col === 13) { targetCol = 8; statType = "GP"; }
                    else return;

                    const currentTotal = xpSheet.getRange(i + 2, targetCol).getValue() || 0;
                    let newTotal = currentTotal + addedValue;

                    // Apply maximum limits for Health and Crystals
                    const playerClass = xpSheet.getRange(i + 2, 2).getValue();
                    if (targetCol === 6) newTotal = Math.min(newTotal, maxValues[playerClass]?.health || newTotal); // Health
                    if (targetCol === 7) newTotal = Math.min(newTotal, maxValues[playerClass]?.crystals || newTotal); // Crystals

                    xpSheet.getRange(i + 2, targetCol).setValue(newTotal);
                    editedCell.setValue(""); // Clear input cell

                    logGameAction(playerName, statType, addedValue, "Teams Sheet Update");
                    break;
                }
            }
        }
    }
}

function logGameAction(playerName, statType, changeValue, action) {
  const logSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
  if (!logSheet) {
    console.error("GameFeed sheet not found.");
    return;
  }

  const timestamp = new Date();
  const formattedTimestamp = Utilities.formatDate(timestamp, Session.getScriptTimeZone(), "yyyy/MM/dd HH:mm:ss");

  // Prepend apostrophe to force string formatting
  const safeChangeValue = `'${changeValue.toString()}`;
  const safeAction = `'${action.toString()}`;

  console.log("Logging action to GameFeed:", {
    formattedTimestamp,
    playerName,
    statType,
    safeChangeValue,
    safeAction,
  });

  logSheet.appendRow([
    formattedTimestamp,
    playerName,
    statType,
    safeChangeValue,
    safeAction,
  ]);

  const latestEntries = getLatestGameFeedEntries();
  broadcastTickertapeUpdate(latestEntries);
}





// Function to handle edits in XP, Mana, Health sheet (IJKL -> EFGH)
function handleXpManaHealthSheetEdit(editedCell, sheet) {
  const col = editedCell.getColumn();
  const row = editedCell.getRow();
  const value = editedCell.getValue();

  if (!value || isNaN(value)) return; // Exit if no value or not a number

  let targetCol;
  if (col === 9) targetCol = 5;  // I -> E (XP)
  else if (col === 10) targetCol = 6; // J -> F (Health)
  else if (col === 11) targetCol = 7; // K -> G (Crystals)
  else if (col === 12) targetCol = 8; // L -> H (GP)
  else return; // Exit if column is not IJKL

  const currentTotal = sheet.getRange(row, targetCol).getValue() || 0;
  const playerClass = sheet.getRange(row, 2).getValue(); // Column B: Class
  const maxValues = {
    Healer: { health: 8, crystals: 5 },
    Mage: { health: 6, crystals: 6 },
    Guardian: { health: 10, crystals: 4 }
  };

  let newTotal = currentTotal + value;

  // Apply maximum limits for Health and Crystals
  if (targetCol === 6) newTotal = Math.min(newTotal, maxValues[playerClass]?.health || newTotal);
  if (targetCol === 7) newTotal = Math.min(newTotal, maxValues[playerClass]?.crystals || newTotal);

  // Update the total and clear the input cell
  sheet.getRange(row, targetCol).setValue(newTotal);
  editedCell.setValue(""); // Clear the input cell after processing

  // Log to GameFeed
  const playerName = sheet.getRange(row, 1).getValue(); // Column A: Player Name
  const statType = targetCol === 5 ? "XP" : targetCol === 6 ? "Health" : targetCol === 7 ? "Crystals" : "GP";
  logGameAction(playerName, statType, value, reason);

  // Additional clearing logic for GP (Column L)
  if (col === 12) {
    sheet.getRange(row, col).setValue(""); // Clear column L explicitly after processing
  }
}




// Function to handle edits in the Teams sheet
function handleTeamsSheetEdit(editedCell, sheet) {
  const row = editedCell.getRow();
  const addedValue = editedCell.getValue();
  const playerName = sheet.getRange(row, 2).getValue();

  if (addedValue && !isNaN(addedValue)) {
    const xpSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const playerNames = xpSheet.getRange("A2:A100").getValues();

    for (let i = 0; i < playerNames.length; i++) {
      if (playerNames[i][0] === playerName) {
        let targetCol, statType;

        if (editedCell.getColumn() === 10) { targetCol = 5; statType = "XP"; }
        else if (editedCell.getColumn() === 11) { targetCol = 6; statType = "Health"; }
        else if (editedCell.getColumn() === 12) { targetCol = 7; statType = "Crystals"; }
        else if (editedCell.getColumn() === 13) { targetCol = 8; statType = "GP"; }
        else return;

        const currentTotal = xpSheet.getRange(i + 2, targetCol).getValue();
        xpSheet.getRange(i + 2, targetCol).setValue(currentTotal + addedValue);
        editedCell.setValue("");

        logGameAction(playerName, statType, addedValue, "Manual Update");
        break;
      }
    }
  }
}


function updatePlayerLevels() { 
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
  const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
  const maxRows = sheet.getLastRow();

  const baseXP = 1500; // XP per level
  const maxLevels = { Mage: 34, Healer: 30, Guardian: 30 };
  const gpBonus = 150; // GP bonus for leveling up
  const currentTime = new Date(); // Timestamp for GameFeed

  for (let row = 2; row <= maxRows; row++) {
    const xp = parseInt(sheet.getRange(row, 5).getValue(), 10); // XP in column E
    const characterClass = sheet.getRange(row, 2).getValue(); // Class in column B
    const currentLevel = parseInt(sheet.getRange(row, 3).getValue(), 10); // Current Level in column C
    const playerName = sheet.getRange(row, 1).getValue(); // Player Name in column A
    const gpTotalCell = sheet.getRange(row, 8); // GP Total in column H

    if (isNaN(xp) || !characterClass) continue;

    let newLevel = Math.floor(xp / baseXP) + 1;
    const maxLevel = maxLevels[characterClass] || 30; // Default max level
    newLevel = Math.min(newLevel, maxLevel);

    if (newLevel !== currentLevel) {
      sheet.getRange(row, 3).setValue(newLevel); // Update Level in column C

      const levelChange = newLevel - currentLevel;
      const changeType = levelChange > 0 ? "Level Up" : "Level Down";

      // **Log the level change (up or down) in GameFeed**
      gameFeedSheet.appendRow([
        Utilities.formatDate(currentTime, Session.getScriptTimeZone(), "yyyy/MM/dd HH:mm:ss"),
        playerName,
        "Level",
        levelChange,
        changeType
      ]);

      Logger.log(`Player level changed: ${playerName} is now level ${newLevel} (${changeType}).`);

      // Add GP bonus only for level-ups
      if (levelChange > 0) {
        const currentGP = parseInt(gpTotalCell.getValue(), 10) || 0; // Get current GP total
        const newGP = currentGP + gpBonus; // Add 150 GP directly to the total
        gpTotalCell.setValue(newGP); // Write the updated GP directly to column H

        // **Log the level-up bonus in GameFeed**
        gameFeedSheet.appendRow([
          Utilities.formatDate(currentTime, Session.getScriptTimeZone(), "yyyy/MM/dd HH:mm:ss"),
          playerName,
          'GP',
          gpBonus,
          'Level Up Bonus'
        ]);
      }
    }
  }
}
function handleTeammateEffect(sheet, playerRow, effectType, powerName) { 
    console.log(`ðŸ”„ handleTeammateEffect STARTED for power: ${powerName}, effectType: ${effectType}`);
    console.log(`handleTeammateEffect invoked for ${powerName} with effect type: ${effectType}`);
    const playerTeam = sheet.getRange(playerRow, 13).getValue(); // Column M: Team
    const playerClass = sheet.getRange(playerRow, 2).getValue(); // Column B: Class
    const teamData = sheet.getRange("M2:M32").getValues(); // Team data for all players

    // Define max values for each class
    const maxValues = {
        Healer: { Health: 8, Crystals: 5 },
        Mage: { Health: 6, Crystals: 6 },
        Guardian: { Health: 10, Crystals: 4 }
    };

    teamData.forEach((team, index) => {
        const teamRow = index + 2; // Rows start from 2
        if (team[0] === playerTeam && teamRow !== playerRow) { // Skip the activating player
            const teammateClass = sheet.getRange(teamRow, 2).getValue(); // Column B: Class
            const teammateName = sheet.getRange(teamRow, 1).getValue();  // Column A: Name

            switch (effectType) {
    case "addCrystals":
        console.log(`Checking teammate: ${teammateName}, Class: ${teammateClass}`); // âœ… Correct placement
        console.log(`Adding crystals to ${teammateName}`);
        
    
        // Check if teammate is a Mage, if so, skip them
        if (teammateClass === "Mage") {
            console.log(`Skipping ${teammateName} because they are a Mage`);
            return; // Exit this iteration, do not add crystals
        }

        // Add crystals, capped by max crystals
        const currentCrystals = sheet.getRange(teamRow, 7).getValue() || 0; // Column G: Crystals
        const maxCrystals = maxValues[teammateClass]?.Crystals || Infinity;
        const newCrystals = Math.min(currentCrystals + 2, maxCrystals); // +2 Crystals for Crystal Transfer

        sheet.getRange(teamRow, 7).setValue(newCrystals); // Update crystals
        logGameAction(teammateName, "Crystals", newCrystals - currentCrystals, powerName); // Log as Crystals
        break;

                case "addHealth":
                    console.log(`Adding health to ${teammateName}`);
                    // Add health, capped by max health
                    const currentHealth = sheet.getRange(teamRow, 6).getValue() || 0; // Column F: Health
                    const maxHealth = maxValues[teammateClass]?.Health || Infinity;
                    const newHealth = Math.min(currentHealth + 2, maxHealth); // +2 Health
                    sheet.getRange(teamRow, 6).setValue(newHealth); // Update health
                    logGameAction(teammateName, "Health", newHealth - currentHealth, powerName); // Log as Health
                    break;

                case "fullHealth":
                    console.log(`Restoring full health to ${teammateName}`);
                    // Restore full health to the teammate
                    const fullHealth = maxValues[teammateClass]?.Health || 0;
                    const currentFullHealth = sheet.getRange(teamRow, 6).getValue() || 0;
                    sheet.getRange(teamRow, 6).setValue(fullHealth); // Set to full health
                    logGameAction(teammateName, "Health", fullHealth - currentFullHealth, powerName); // Log as full health restoration
                    break;

                case "targetedHealth":
                    console.log(`Targeted health addition for ${teammateName}`);
                    // Allow targeting a specific teammate for health addition
                    const selectedTeammateRow = promptForTeammateRow(sheet, playerTeam, playerRow);
                    if (selectedTeammateRow !== -1) {
                        const targetedCurrentHealth = sheet.getRange(selectedTeammateRow, 6).getValue() || 0; // Column F: Health
                        const targetedMaxHealth = maxValues[teammateClass]?.Health || Infinity;
                        const targetedNewHealth = Math.min(targetedCurrentHealth + 1, targetedMaxHealth); // +1 Health
                        sheet.getRange(selectedTeammateRow, 6).setValue(targetedNewHealth);
                        logGameAction(sheet.getRange(selectedTeammateRow, 1).getValue(), "Health", targetedNewHealth - targetedCurrentHealth, powerName); // Log targeted health change
                    }
                    break;

                default:
                    console.warn(`Unknown effect type: ${effectType}`);
            }
        }
    });
}



function getTeammates() {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Teams");
    const data = sheet.getDataRange().getValues();

    return data.map(row => ({
        id: row[0], // Unique ID
        name: row[1] // Name
    }));
}
function getTeammatesForDropdown(uniqueId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const playerRow = findPlayerRowById(sheet, uniqueId); // Locate the player by uniqueId

    if (playerRow === -1) {
        console.log("Player not found with uniqueId:", uniqueId);
        return []; // Return empty if player not found
    }

    // Get the player's team (Column M)
    const playerTeam = sheet.getRange(playerRow, 13).getValue(); // Column M: Team
    console.log("Player's team found:", playerTeam);

    // Fetch all relevant rows (Columns A-N)
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 14).getValues();

    // Filter teammates by the same team and exclude the current player
    const teammates = data
        .filter(row => row[12] === playerTeam && row[13] !== uniqueId) // Match team and exclude the current player
        .map(row => ({
            id: row[13], // Unique ID (Column N)
            name: row[0], // Player Name (Column A)
        }));

    console.log("Filtered teammates for dropdown (names):", teammates);
    return teammates;
}


function findPlayerRowById(sheet, uniqueId) {
  try {
    const data = sheet.getRange('N2:N32').getValues(); // Column N
    Logger.log("ðŸ”Ž Searching for Unique ID: " + uniqueId);

    for (let i = 0; i < data.length; i++) {
      const rowValue = data[i][0];
      Logger.log(`Row ${i + 2}: value='${rowValue}'`);

      if (rowValue && rowValue.toString().trim() === uniqueId.toString().trim()) {
        Logger.log(`âœ… Match found at row ${i + 2}`);
        return i + 2;
      }
    }

    Logger.log(`âŒ No match found for Unique ID: '${uniqueId}'`);
    return -1;
  } catch (error) {
    Logger.log(`â— Error in findPlayerRowById: ${error.message}`);
    return -1;
  }
}


function getPlayerData(uniqueId) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('XP, Mana, Health');
  const playerRow = findPlayerRowById(sheet, uniqueId);
  if (playerRow === -1) return null;

  const data = sheet.getRange(playerRow, 1, 1, 13).getValues()[0];
  const characterClass = data[1]; // Column B
  const level = data[2];          // Column C
  const gender = data[3];         // Column D
  
  const imageUrl = getPlayerImage(characterClass, level, gender);

  return {
    playerName: data[0],            // Column A
    characterClass: characterClass,
    level: level,
    xp: data[4],                    // Column E
    health: data[5],                // Column F
    crystals: data[6],              // Column G
    goldPieces: data[7],            // Column H
    team: data[12],                 // Column M
    imageUrl: imageUrl              // Include the image URL
  };
}

function getPlayerImage(className, level, gender) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Vlookup Sheet');
  if (!sheet) return 'https://example.com/default.jpg'; // Fallback image URL
  
  const data = sheet.getDataRange().getValues();
  let closestImageUrl = 'https://example.com/default.jpg'; // Default fallback image
  let closestLevel = -1; // To store the closest lower level match

  // Search for a matching or closest lower-level image in the lookup table
  for (let i = 1; i < data.length; i++) { // Skip the header row
    const [lookupClass, lookupLevel, lookupGender, imageUrl] = data[i];
    const parsedLevel = parseInt(lookupLevel);

    if (
      lookupClass === className &&
      lookupGender === gender &&
      parsedLevel <= level && // Check for levels less than or equal to the current level
      parsedLevel > closestLevel // Ensure it's the closest lower level
    ) {
      closestLevel = parsedLevel; // Update the closest level
      closestImageUrl = imageUrl; // Update the image URL
    }
  }

  return closestImageUrl; // Return the closest matching image URL
}


// Helper to apply stat changes and log them
function addPetFeedPoint(uniqueId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('XP, Mana, Health');
    const logSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(LOG_SHEET_NAME);
    const playerRow = findPlayerRowById(sheet, uniqueId);

    if (playerRow === -1) {
        return "Unique ID not found."; // Player not found
    }

    const gpClearingCell = sheet.getRange(playerRow, 12); // Column L (Clearing House)
    const gpTotalCell = sheet.getRange(playerRow, 8);     // Column H (Totals)
    const lastFeedCell = sheet.getRange(playerRow, 15);   // Column O (Last Feed Date)
    const playerName = sheet.getRange(playerRow, 1).getValue();

    const currentGP = gpTotalCell.getValue() || 0;  // Current total GP
    const addedGP = 10;                             // GP to add
    const currentDate = formatDate(new Date());     // Format today's date as "DD/MM/YYYY"
    let lastFeedDate = lastFeedCell.getValue();

    // Ensure lastFeedDate is a string in the correct format
    if (lastFeedDate instanceof Date) {
        lastFeedDate = formatDate(lastFeedDate);
    } else if (!lastFeedDate || typeof lastFeedDate !== 'string') {
        console.warn(`Unexpected value in lastFeedDate: ${lastFeedDate}`);
        lastFeedDate = "01/01/1900"; // Default very old date to allow feeding
    }

    // Check if the player has already fed their pet today
    if (lastFeedDate === currentDate) {
        return "You have already fed your pet today!";
    }

    // Log the current date before writing to the sheet
    console.log(`Writing current date (${currentDate}) for player ${playerName}`);

    // Allow feeding: Add 10 GP, update totals, and mark today's date
    gpClearingCell.setValue(addedGP);                       // Add 10 GP to clearing house (L)
    gpTotalCell.setValue(currentGP + addedGP);              // Update total in column H
    gpClearingCell.setValue("");                            // Clear column L
    lastFeedCell.setValue(currentDate);                     // Mark today's feed date

    // Log the action
    logGameAction(playerName, "GP", addedGP, "Feed Pet");

    // Send success message in plain text for modal display
    return "Yum! Your pet is fed and happy!";
}


// Helper function to format dates as "DD/MM/YYYY"
function formatDate(date) {
    const day = String(date.getDate()).padStart(2, '0');  // Add leading zero
    const month = String(date.getMonth() + 1).padStart(2, '0');  // Month is 0-indexed
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}




// Function to get the pet feed image URL (cycling every 20 days)
function getPetImage() {
  const lookupSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PET_IMAGE_SHEET_NAME);
  if (!lookupSheet) return 'https://example.com/default.jpg'; // Fallback image URL

  const today = new Date();
  const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 86400000); // Days since Jan 1
  const imageListLength = PET_IMAGE_CYCLE_END - PET_IMAGE_CYCLE_START + 1; // Total images in the list
  const blockCycle = Math.floor(dayOfYear / 20) % imageListLength; // Calculate the image block (20 days per image)
  
  const imageRow = PET_IMAGE_CYCLE_START + blockCycle; // Row for the current image
  return lookupSheet.getRange(imageRow, 3).getValue(); // Column C contains the image URL
}


// Modal Pop-up Function
function showModal(message) {
  const htmlOutput = HtmlService.createHtmlOutput(
    `<div style="font-size: 20px; text-align: center; padding: 20px;">${message}</div>`
  )
    .setWidth(300)
    .setHeight(100);
  SpreadsheetApp.getUi().showModalDialog(htmlOutput, 'Notification');
}

// Function to add 0.5 Crystals daily up to class caps
function addDailyCrystals() {
  const newSpreadsheet = SpreadsheetApp.openById('1TrkC9zLxgOIlBTqFV7jtoGAbROTDXUOHoxw0sNhp-CA'); // Use the current spreadsheet ID
  const sheet = newSpreadsheet.getSheetByName('XP, Mana, Health'); // Explicitly open the correct sheet
  const data = sheet.getRange('B2:G32').getValues(); // Columns: Character Class to Mana Crystals

  for (let i = 0; i < data.length; i++) {
    const [playerClass, , , , , currentCrystals] = data[i]; // Read from column G (Mana Crystals)
    if (playerClass && DAILY_CRYSTAL_CAPS[playerClass] > currentCrystals) { // Check against class-specific cap
      const row = i + 2; // Row in the spreadsheet
      const crystalCell = sheet.getRange(row, 7); // Column G for Mana Crystals
      crystalCell.setValue(currentCrystals + 0.5); // Add 0.5 to the current value and update
      logGameAction(sheet.getRange(row, 1).getValue(), "Crystals", 0.5, "Daily Crystal Bonus"); // Log the action
    }
  }
}

function activatePower(uniqueId, powerName, crystalChange, healthChange, xpChange, teammateEffect = null) {
    console.log("ActivatePower function called with effect type:", teammateEffect);
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const row = findPlayerRowById(sheet, uniqueId);  // Find the row of the player
    if (row === -1) return `Player not found.`;

    const playerName = sheet.getRange(row, 1).getValue(); // Column A: Player Name
    const playerClass = sheet.getRange(row, 2).getValue(); // Column B: Class

    // Define max values for each class
    const maxValues = {
        Healer: { health: 8, crystals: 5 },
        Mage: { health: 6, crystals: 6 },
        Guardian: { health: 10, crystals: 4 }
    };

    const maxHealth = maxValues[playerClass]?.health || Infinity;
    const maxCrystals = maxValues[playerClass]?.crystals || Infinity;

    // Crystals Update
    if (crystalChange) {
        const currentCrystals = sheet.getRange(row, 7).getValue() || 0; // Column G: Crystals
        const newCrystals = Math.min(currentCrystals + crystalChange, maxCrystals);
        const crystalDifference = newCrystals - currentCrystals; // Calculate change
        sheet.getRange(row, 7).setValue(newCrystals);
        logGameAction(playerName, "Crystals", (crystalDifference >= 0 ? "+" : "") + crystalDifference, powerName); // Log difference
    }

    // Health Update for Self
    if (healthChange) {
        const currentHealth = sheet.getRange(row, 6).getValue() || 0; // Column F: Health
        const newHealth = Math.min(currentHealth + healthChange, maxHealth);
        const healthDifference = newHealth - currentHealth; // Calculate change
        sheet.getRange(row, 6).setValue(newHealth);
        logGameAction(playerName, "Health", (healthDifference >= 0 ? "+" : "") + healthDifference, powerName); // Log difference
    }

    // Team Effects
    if (teammateEffect) {
        console.log(`Applying teammate effect: ${teammateEffect}`);
        const playerTeam = sheet.getRange(row, 13).getValue(); // Column M: Team
        const teamData = sheet.getRange("M2:M32").getValues(); // Team data for all players

        // Apply effect to all teammates based on their max values
        teamData.forEach((team, index) => {
            const teamRow = index + 2; // Rows start from 2
            if (team[0] === playerTeam && teamRow !== row) { // Same team, skip triggering player
                const teammateClass = sheet.getRange(teamRow, 2).getValue(); // Column B: Class
                const teammateName = sheet.getRange(teamRow, 1).getValue(); // Column A: Name
                const maxTeammateHealth = maxValues[teammateClass]?.health || Infinity;

                if (teammateEffect === "addHealth") {
                    // Add health, capped by teammate's max health
                    const currentTeammateHealth = sheet.getRange(teamRow, 6).getValue() || 0; // Column F: Health
                    const newTeammateHealth = Math.min(currentTeammateHealth + 2, maxTeammateHealth); // +2 Health
                    const teammateHealthDifference = newTeammateHealth - currentTeammateHealth;
                    sheet.getRange(teamRow, 6).setValue(newTeammateHealth); // Update health
                    logGameAction(teammateName, "Health", (teammateHealthDifference >= 0 ? "+" : "") + teammateHealthDifference, powerName); // Log difference
                } else if (teammateEffect === "addCrystals") {
                console.log(`Checking teammate: ${teammateName}, Class: ${teammateClass}`);

                // **Skip Mages from receiving Crystals**
                if (teammateClass === "Mage") {
                    console.log(`Skipping ${teammateName} because they are a Mage`);
                    return; // Stop execution for Mages
                }

                const maxTeammateCrystals = maxValues[teammateClass]?.crystals || Infinity;
                const currentTeammateCrystals = sheet.getRange(teamRow, 7).getValue() || 0; // Column G: Crystals
                const newTeammateCrystals = Math.min(currentTeammateCrystals + 2, maxTeammateCrystals); // +2 Crystals
                const teammateCrystalDifference = newTeammateCrystals - currentTeammateCrystals;
                
                sheet.getRange(teamRow, 7).setValue(newTeammateCrystals); // Update crystals
                logGameAction(teammateName, "Crystals", (teammateCrystalDifference >= 0 ? "+" : "") + teammateCrystalDifference, powerName); // Log difference
                }
            }
        });
    }

    // XP Update
    if (xpChange) {
        const currentXP = sheet.getRange(row, 5).getValue() || 0; // Column E: XP
        const xpDifference = xpChange; // XP change is always a direct addition/subtraction
        sheet.getRange(row, 5).setValue(currentXP + xpChange);
        logGameAction(playerName, "XP", (xpDifference >= 0 ? "+" : "") + xpDifference, powerName); // Log as +XPChange
    }

    return `${powerName} Activated!`;
}

// Specific Universal Powers
function useInvisibilityButton(uniqueId) {
    const result = activatePower(uniqueId, "Invisibility", -1, null, null);
    return result;
}

function useForageButton(uniqueId) {
    const result = activatePower(uniqueId, "Forage", -1, null, null);
    return result;
}

function useSainthoodButton(uniqueId) {
    const result = activatePower(uniqueId, "Sainthood", -2, null, null);
    return result;
}



// Specific Power Functions
// Healer Power: Heal 1
function useHeal1Button(uniqueId) {
    return activatePower(uniqueId, "Heal 1", -2, 2, null, "addHealth");
    // Cost: -2 Crystals, +2 Health for the Player, and +2 Health for teammates
}

// Healer Power: Respite
function useRespiteButton(uniqueId) {
    return activatePower(uniqueId, "Respite", -2, null, null); // -2 Crystals, No other changes
}

// Healer Power: Ardent Faith
function useArdentFaithButton(uniqueId) {
    return activatePower(uniqueId, "Ardent Faith", -2, null, 100); // -2 Crystals, +100 XP
}

// Healer Power: Revive
function useReviveButton(playerId, teammateId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed"); // Access GameFeed sheet

    // Find player and teammate rows
    const playerRow = findPlayerRowById(sheet, playerId);
    const teammateRow = findPlayerRowById(sheet, teammateId);

    if (playerRow === -1 || teammateRow === -1) {
        return `Error: Invalid player or teammate ID.`;
    }

    const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
    const teammateName = sheet.getRange(teammateRow, 1).getValue(); // Column A: Teammate Name

    // Check teammate's health
    const healthCell = sheet.getRange(teammateRow, 6); // Column F: Health
    const currentHealth = healthCell.getValue() || 0;

    if (currentHealth > 0) {
        return `${teammateName} is not at 0 or negative health and cannot be revived. No crystals were used.`;
    }

    // Deduct Crystals
    const crystalsCell = sheet.getRange(playerRow, 7); // Column G: Crystals
    const currentCrystals = crystalsCell.getValue() || 0;
    if (currentCrystals < 2) {
        return `Not enough crystals to use Revive.`;
    }
    crystalsCell.setValue(currentCrystals - 2);
    logGameAction(playerName, "Crystals", -2, "Revive");

    // Add XP to healer
    const xpCell = sheet.getRange(playerRow, 5); // Column E: XP
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + 150); // Add 150 XP
    logGameAction(playerName, "XP", 150, "Revive");

    // Revive teammate by setting health to 1
    healthCell.setValue(1); // Set to 1 heart
    logGameAction(teammateName, "Health", 1 - currentHealth, "Revive");

    // Log specific message to GameFeed
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy/MM/dd HH:mm:ss");
gameFeedSheet.appendRow([timestamp, playerName, "Revive", `Revived ${teammateName} and set to 1 heart`]);

    return `${teammateName} has been revived with 1 heart! You earned 150 XP and used 2 Crystals.`;
}


// Healer Power: Favour of the Gods
function useFavourOfTheGodsButton(uniqueId) {
    return activatePower(uniqueId, "Favour of the Gods", -2, null, null); // -2 Crystals, No other changes
}

function useHeal2Button(playerId, teammateId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
    
    // Find player and teammate rows
    const playerRow = findPlayerRowById(sheet, playerId);
    const teammateRow = teammateId && teammateId !== "self" ? findPlayerRowById(sheet, teammateId) : playerRow;

    if (playerRow === -1 || teammateRow === -1) {
        return `Error: Invalid player or teammate ID.`;
    }

    // Deduct Crystals from the player
    const crystalsCell = sheet.getRange(playerRow, 7); // Column G: Crystals
    const currentCrystals = crystalsCell.getValue() || 0;

    if (currentCrystals < 2) {
        return `Not enough crystals to use Heal 2.`;
    }

    crystalsCell.setValue(currentCrystals - 2);
    logGameAction(sheet.getRange(playerRow, 1).getValue(), "Crystals", -2, "Heal 2");

    // Add XP to the player
    const xpCell = sheet.getRange(playerRow, 5); // Column E: XP
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + 100);
    logGameAction(sheet.getRange(playerRow, 1).getValue(), "XP", 100, "Heal 2");

    // Add Health to the teammate
    const healthCell = sheet.getRange(teammateRow, 6); // Column F: Health
    const currentHealth = healthCell.getValue() || 0;

    const teammateClass = sheet.getRange(teammateRow, 2).getValue(); // Column B: Class
    const maxHealth = {
        Healer: 8,
        Mage: 6,
        Guardian: 10
    }[teammateClass] || 10;

    const newHealth = Math.min(currentHealth + 5, maxHealth); // Add 5 health, cap at max
    const healthAdded = newHealth - currentHealth;

    healthCell.setValue(newHealth);

    // Log health addition to GameFeed
    const teammateName = sheet.getRange(teammateRow, 1).getValue(); // Column A: Name
    logGameAction(teammateName, "Health", healthAdded, "Heal 2");

    // Feedback message
    return `Healed ${teammateName} by ${healthAdded} hearts. You earned 100 XP and used 2 Crystals.`;
}


function getMaxHealth(characterClass) {
    const maxValues = {
        Mage: 6,
        Healer: 8,
        Guardian: 10
    };
    return maxValues[characterClass] || 6; // Default to 6 if class is unknown
}

// Healer Power: Healing Circle
function useHealingCircleButton(uniqueId) {
    return activatePower(uniqueId, "Healing Circle", -3, null, 200, "addHealth"); // -3 Crystals, Team +3 Health, +200 XP
}

function useHeal3Button(playerId, teammateId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");

    // Find player and teammate rows
    const playerRow = findPlayerRowById(sheet, playerId);
    const teammateRow = teammateId !== "self" ? findPlayerRowById(sheet, teammateId) : playerRow;

    if (playerRow === -1 || teammateRow === -1) {
        return `Error: Invalid player or teammate ID.`;
    }

    const playerName = sheet.getRange(playerRow, 1).getValue();
    const teammateName = sheet.getRange(teammateRow, 1).getValue();

    console.log(`Player: ${playerName}, Teammate: ${teammateName}`);

    // Deduct Crystals
    const crystalsCell = sheet.getRange(playerRow, 7); // Column G: Crystals
    const currentCrystals = crystalsCell.getValue() || 0;
    if (currentCrystals < 3) {
        return `Not enough crystals to use Heal 3.`;
    }
    crystalsCell.setValue(currentCrystals - 3); // Deduct 3 crystals
    logGameAction(playerName, "Crystals", -3, "Heal 3");

    // Add XP
    const xpCell = sheet.getRange(playerRow, 5); // Column E: XP
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + 250); // Add 250 XP
    logGameAction(playerName, "XP", 250, "Heal 3");

    // Add full health to teammate
    const healthCell = sheet.getRange(teammateRow, 6); // Column F: Health
    const currentHealth = healthCell.getValue() || 0;

    const teammateClass = sheet.getRange(teammateRow, 2).getValue(); // Column B: Class
    const maxHealth = {
        Healer: 8,
        Mage: 6,
        Guardian: 10
    }[teammateClass] || 10;

    console.log(`Current Health: ${currentHealth}, Max Health: ${maxHealth}`);

    const healthAdded = maxHealth - currentHealth;

    if (healthAdded > 0) {
        healthCell.setValue(maxHealth); // Set full health
        logGameAction(teammateName, "Health", healthAdded, "Heal 3");
        return `${teammateName} has been fully healed! You gained 250 XP and used 3 Crystals.`;
    } else {
        return `${teammateName} already has full health.`;
    }
}





// Server-side function for applying full health to teammate
function applyFullHealth(playerId, teammateId, powerName, crystalCost, xpReward) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const playerRow = findPlayerRowById(sheet, playerId);
    const teammateRow = teammateId === "self" ? playerRow : findPlayerRowById(sheet, teammateId);

    if (playerRow === -1 || teammateRow === -1) return `Invalid player or teammate ID.`;

    const playerName = sheet.getRange(playerRow, 1).getValue();
    const teammateName = sheet.getRange(teammateRow, 1).getValue();

    // Deduct crystals
    const crystalsCell = sheet.getRange(playerRow, 7);
    const currentCrystals = crystalsCell.getValue() || 0;

    if (currentCrystals < crystalCost) {
        return `${playerName}, you don't have enough crystals for ${powerName}.`;
    }
    crystalsCell.setValue(currentCrystals - crystalCost);
    logGameAction(playerName, "Crystals", -crystalCost, powerName);

    // Add XP
    const xpCell = sheet.getRange(playerRow, 5);
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + xpReward);
    logGameAction(playerName, "XP", xpReward, powerName);

    // Restore full health
    const maxHealth = getMaxHealth(sheet.getRange(teammateRow, 2).getValue());
    const healthCell = sheet.getRange(teammateRow, 6);
    const currentHealth = healthCell.getValue() || 0;
    const healthAdded = maxHealth - currentHealth;

    if (healthAdded > 0) {
        healthCell.setValue(maxHealth);
        logGameAction(teammateName, "Health", healthAdded, powerName);
    }

    return `${teammateName} has been fully healed! ${playerName} gained ${xpReward} XP and spent ${crystalCost} Crystals.`;
}


// Healer Power: Prayer
function usePrayerButton(uniqueId) {
    return activatePower(uniqueId, "Prayer", -4, null, null); // -4 Crystals, No direct changes (manual effect)
}

function useGuard1Button(playerId, teammateId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");

    // Find player and teammate rows
    const playerRow = findPlayerRowById(sheet, playerId);
    const teammateRow = teammateId !== "self" ? findPlayerRowById(sheet, teammateId) : playerRow;

    if (playerRow === -1 || teammateRow === -1) {
        return `Error: Invalid player or teammate ID.`;
    }

    const playerName = sheet.getRange(playerRow, 1).getValue();
    const teammateName = sheet.getRange(teammateRow, 1).getValue();

    // Deduct 1 crystal
    const crystalsCell = sheet.getRange(playerRow, 7); // Column G: Crystals
    const currentCrystals = crystalsCell.getValue() || 0;
    if (currentCrystals < 1) {
        return `Not enough crystals to use Guard 1.`;
    }
    crystalsCell.setValue(currentCrystals - 1); // Deduct 1 crystal
    logGameAction(playerName, "Crystals", -1, "Guard 1");

    // Subtract 2 hearts from the Guardian
    const guardianHealthCell = sheet.getRange(playerRow, 6); // Column F: Health
    const currentGuardianHealth = guardianHealthCell.getValue() || 0;
    guardianHealthCell.setValue(currentGuardianHealth - 2);
    logGameAction(playerName, "Health", -2, "Guard 1");

    // Add 50 XP to the Guardian
    const xpCell = sheet.getRange(playerRow, 5); // Column E: XP
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + 50); // Add 50 XP
    logGameAction(playerName, "XP", 50, "Guard 1");

    // Add 1 heart to the teammate
    const teammateHealthCell = sheet.getRange(teammateRow, 6); // Column F: Health
    const currentTeammateHealth = teammateHealthCell.getValue() || 0;

    const teammateClass = sheet.getRange(teammateRow, 2).getValue(); // Column B: Class
    const maxHealth = {
        Healer: 8,
        Mage: 6,
        Guardian: 10
    }[teammateClass] || 10;

    const newTeammateHealth = Math.min(currentTeammateHealth + 1, maxHealth); // Cap at max health
    teammateHealthCell.setValue(newTeammateHealth);

    logGameAction(teammateName, "Health", 1, "Guard 1");

    return `${teammateName} was protected and gained 1 heart! ${playerName} lost 2 hearts, used 1 Crystal, and gained 50 XP.`;
}



function useFrontalAssaultButton(uniqueId) {
  return activatePower(uniqueId, "Frontal Assault", -2, null, null);
  // Cost: 2 Crystals, No other stat change
}

function useFirstAidButton(uniqueId) { 
  return activatePower(uniqueId, "First Aid", -2, 2, 10); 
  // Cost: 2 Crystals, Player adds +2 Health (column F = 6)
}

function useCounterAttackButton(uniqueId) {
  return activatePower(uniqueId, "Counter Attack", -3, null, null);
  // Cost: 3 Crystals, No other stat change
}

function useGuard2Button(playerId, teammateId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");

    // Find player and teammate rows
    const playerRow = findPlayerRowById(sheet, playerId);
    const teammateRow = teammateId !== "self" ? findPlayerRowById(sheet, teammateId) : playerRow;

    if (playerRow === -1 || teammateRow === -1) {
        return `Error: Invalid player or teammate ID.`;
    }

    const playerName = sheet.getRange(playerRow, 1).getValue();
    const teammateName = sheet.getRange(teammateRow, 1).getValue();

    // Deduct 2 crystals
    const crystalsCell = sheet.getRange(playerRow, 7); // Column G: Crystals
    const currentCrystals = crystalsCell.getValue() || 0;
    if (currentCrystals < 2) {
        return `Not enough crystals to use Guard 2.`;
    }
    crystalsCell.setValue(currentCrystals - 2); // Deduct 2 crystals
    logGameAction(playerName, "Crystals", -2, "Guard 2");

    // Add 100 XP to the Guardian
    const xpCell = sheet.getRange(playerRow, 5); // Column E: XP
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + 100); // Add 100 XP
    logGameAction(playerName, "XP", 100, "Guard 2");

    // Add 3 hearts to the selected player
    const teammateHealthCell = sheet.getRange(teammateRow, 6); // Column F: Health
    const currentTeammateHealth = teammateHealthCell.getValue() || 0;

    const teammateClass = sheet.getRange(teammateRow, 2).getValue(); // Column B: Class
    const maxHealth = {
        Healer: 8,
        Mage: 6,
        Guardian: 10
    }[teammateClass] || 10;

    const newTeammateHealth = Math.min(currentTeammateHealth + 3, maxHealth); // Cap at max health
    teammateHealthCell.setValue(newTeammateHealth);

    logGameAction(teammateName, "Health", newTeammateHealth - currentTeammateHealth, "Guard 2");

    return `${teammateName} was protected and gained 3 hearts! ${playerName} used 2 Crystals and gained 100 XP.`;
}


function useFrontalAssault2Button(uniqueId) {
  return activatePower(uniqueId, "Frontal Assault 2", -4, 5, 200);
  // Cost: 4 Crystals, Player gains +200 XP (column E = 5)
}

function useDefenseOfTheCastleButton(uniqueId) {
  return activatePower(uniqueId, "Defense of the Castle", -4, null, null);
  // Cost: 4 Crystals, No other stat change
}

function useGuardAllButton(playerId) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");

    // Find player row
    const playerRow = findPlayerRowById(sheet, playerId);
    if (playerRow === -1) {
        return `Error: Invalid player ID.`;
    }

    const playerName = sheet.getRange(playerRow, 1).getValue();
    const playerTeam = sheet.getRange(playerRow, 13).getValue(); // Column M: Team

    // Deduct 3 crystals
    const crystalsCell = sheet.getRange(playerRow, 7); // Column G: Crystals
    const currentCrystals = crystalsCell.getValue() || 0;
    if (currentCrystals < 3) {
        return `Not enough crystals to use Guard All.`;
    }
    crystalsCell.setValue(currentCrystals - 3); // Deduct 3 crystals
    logGameAction(playerName, "Crystals", -3, "Guard All");

    // Subtract 5 hearts from the Guardian
    const guardianHealthCell = sheet.getRange(playerRow, 6); // Column F: Health
    const currentGuardianHealth = guardianHealthCell.getValue() || 0;
    guardianHealthCell.setValue(Math.max(0, currentGuardianHealth - 5)); // Subtract 5 hearts (don't go below 0)
    logGameAction(playerName, "Health", -5, "Guard All");

    // Add 200 XP to the Guardian
    const xpCell = sheet.getRange(playerRow, 5); // Column E: XP
    const currentXP = xpCell.getValue() || 0;
    xpCell.setValue(currentXP + 200); // Add 200 XP
    logGameAction(playerName, "XP", 200, "Guard All");

    // Add 3 hearts to all teammates (except the Guardian)
    const teamData = sheet.getRange("M2:M32").getValues(); // Get all team assignments (Column M)
    teamData.forEach((team, index) => {
        const teamRow = index + 2; // Rows start at 2
        if (team[0] === playerTeam && teamRow !== playerRow) {
            const teammateName = sheet.getRange(teamRow, 1).getValue();
            const teammateClass = sheet.getRange(teamRow, 2).getValue(); // Column B: Class
            const teammateHealthCell = sheet.getRange(teamRow, 6); // Column F: Health
            const currentTeammateHealth = teammateHealthCell.getValue() || 0;

            const maxHealth = {
                Healer: 8,
                Mage: 6,
                Guardian: 10
            }[teammateClass] || 10;

            const newTeammateHealth = Math.min(currentTeammateHealth + 3, maxHealth); // Cap at max health
            teammateHealthCell.setValue(newTeammateHealth);

            logGameAction(teammateName, "Health", newTeammateHealth - currentTeammateHealth, "Guard All");
        }
    });

    return `${playerName} protected the team! All teammates gained 3 hearts. You lost 5 hearts, used 3 Crystals, and gained 200 XP.`;
}



function useSecretWeaponButton(uniqueId) {
  return activatePower(uniqueId, "Secret Weapon", -4, null, null);
  // Cost: 4 Crystals, No other stat change
}

// Mage Powers
function useCrystalTransferButton(uniqueId) {
    return activatePower(uniqueId, "Crystal Transfer", -3, null, 100, "addCrystals");
    // Subtract 3 Crystals, Add 100 XP to Activator, +1 Crystal to All Teammates
}


function useGenerosityAndSacrifice(uniqueId) {
  return activatePower(uniqueId, "Generosity and Sacrifice", -2, null, null);
  // Cost: 2 Crystals, No other stat change
}

function useTheCall(uniqueId) {
  return activatePower(uniqueId, "The Call", -2, null, null);
  // Cost: 2 Crystals, No other stat change
}

function useTeleport(uniqueId) {
  return activatePower(uniqueId, "Teleport", -2, null, null);
  // Cost: 2 Crystals, No other stat change
}

function useManaShield(uniqueId) {
  return activatePower(uniqueId, "Mana Shield", -2, null, null);
  // Cost: 2 Crystals, No other stat change
}

function useClairvoyance(uniqueId) {
  return activatePower(uniqueId, "Clairvoyance", -3, null, null);
  // Cost: 3 Crystals, No other stat change
}

function useCheatDeath(uniqueId) {
  return activatePower(uniqueId, "Cheat Death", -2, null, null);
  // Cost: 2 Crystals, No other stat change
}

function useTimeWarp(uniqueId) {
  return activatePower(uniqueId, "Time Warp", -2, null, null);
  // Cost: 3 Crystals, No other stat change
}

function useCrystalManaFountain(uniqueId) {
  return activatePower(uniqueId, "Crystal Mana Fountain", -4, 5, 200, 1);
  // Cost: 4 Crystals, Player gains +200 XP, Teammates gain +1 Crystal
}

function useMageCircle(uniqueId) {
  return activatePower(uniqueId, "Mage Circle", -4, null, null);
  // Cost: 4 Crystals, No other stat change
}

function promptForTeammateRow(sheet, playerTeam, playerRow) {
    const teamData = sheet.getRange("M2:M32").getValues();
    const teammateOptions = [];

    teamData.forEach((team, index) => {
        if (team[0] === playerTeam && index + 2 !== playerRow) { // Exclude the activating player
            const playerName = sheet.getRange(index + 2, 1).getValue(); // Column A: Player Name
            teammateOptions.push({ row: index + 2, name: playerName });
        }
    });

    if (teammateOptions.length === 0) return -1; // No teammates found

    const teammateNames = teammateOptions.map(teammate => teammate.name).join(", ");
    const selectedTeammateName = Browser.inputBox(`Choose a teammate: ${teammateNames}`);

    const selectedTeammate = teammateOptions.find(teammate => teammate.name === selectedTeammateName);
    return selectedTeammate ? selectedTeammate.row : -1;
}

function useTinkerer(uniqueId) {
    try {
        console.log(`useTinkerer called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 900; // Cost of Tinkerer
        if (currentGP < cost) {
            console.log(`Insufficient GP for Tinkerer. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Tinkerer (Insufficient GP)"]);
            return `You don't have enough GP for Tinkerer.`;
        }

        // Deduct GP
        gpClearingCell.setValue(-cost); // Subtract GP in clearing house
        gpTotalCell.setValue(currentGP - cost); // Update GP total
        gpClearingCell.setValue(""); // Clear clearing house after processing

        console.log(`Tinkerer Activated for Player with Unique ID: ${uniqueId}`);
        
        // Log successful purchase
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Tinkerer"]);
        return `Tinkerer Activated!`;
    } catch (error) {
        console.error(`Error in useTinkerer: ${error.message}`, error.stack);
        return "An error occurred while activating Tinkerer.";
    }
}
function usePlanner(uniqueId) {
    try {
        console.log(`usePlanner called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 500; // Cost of The Planner
        if (currentGP < cost) {
            console.log(`Insufficient GP for The Planner. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "The Planner (Insufficient GP)"]);
            return `You don't have enough GP for The Planner.`;
        }

        // Deduct GP
        gpClearingCell.setValue(-cost); // Subtract GP in clearing house
        gpTotalCell.setValue(currentGP - cost); // Update GP total
        gpClearingCell.setValue(""); // Clear clearing house after processing

        console.log(`The Planner Activated for Player with Unique ID: ${uniqueId}`);
        
        // Log successful purchase
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "The Planner"]);
        return `The Planner Activated!`;
    } catch (error) {
        console.error(`Error in usePlanner: ${error.message}`, error.stack);
        return "An error occurred while activating The Planner.";
    }
}
function useDeal(uniqueId) {
    try {
        console.log(`useDeal called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 600; // Cost of Deal
        if (currentGP < cost) {
            console.log(`Insufficient GP for Deal. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Deal (Insufficient GP)"]);
            return `You don't have enough GP for Deal.`;
        }

        // Deduct GP
        gpClearingCell.setValue(-cost); // Subtract GP in clearing house
        gpTotalCell.setValue(currentGP - cost); // Update GP total
        gpClearingCell.setValue(""); // Clear clearing house after processing

        console.log(`Deal Activated for Player with Unique ID: ${uniqueId}`);
        
        // Log successful purchase
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Deal"]);
        return `Deal Activated!`;
    } catch (error) {
        console.error(`Error in useDeal: ${error.message}`, error.stack);
        return "An error occurred while activating Deal.";
    }
}
function useWheel(uniqueId) {
    try {
        console.log("Entering useWheel with uniqueId:", uniqueId); // Log the function entry and input

        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        if (!sheet) {
            console.error("XP, Mana, Health sheet not found."); // Log missing sheet
            return JSON.stringify({ success: false, message: "Game data sheet not found." });
        }
        if (!gameFeedSheet) {
            console.error("GameFeed sheet not found."); // Log missing sheet
            return JSON.stringify({ success: false, message: "Game log sheet not found." });
        }

        const playerRow = findPlayerRowById(sheet, uniqueId);
        if (playerRow === -1) {
            console.warn("Player not found with uniqueId:", uniqueId); // Log missing player
            return JSON.stringify({ success: false, message: "Player not found." });
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const currentGP = gpTotalCell.getValue() || 0;

        console.log(`Player Name: ${playerName}, Current GP: ${currentGP}`); // Log player details

        if (currentGP < 100) {
            console.warn(`Player ${playerName} has insufficient GP (${currentGP}) for Wheel of Destiny.`); // Log insufficient GP
            return JSON.stringify({ success: false, message: "Insufficient GP." });
        }

        // Deduct GP
        gpTotalCell.setValue(currentGP - 100);
        console.log(`Deducted 100 GP from player ${playerName}. New GP: ${currentGP - 100}`); // Log deduction

        // Log the event
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -100, "Wheel of Destiny"]);
        console.log(`Logged Wheel of Destiny purchase for player ${playerName}.`); // Log gameFeed entry

        return JSON.stringify({ success: true, message: "Wheel of Destiny Purchased!" });
    } catch (error) {
        console.error("Error in useWheel:", error); // Log the error
        return JSON.stringify({ success: false, message: "An error occurred." });
    }
}

function useTransfiguration(uniqueId) {
    try {
        console.log(`useTransfiguration called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const currentGP = parseInt(gpTotalCell.getValue(), 10) || 0;

        const cost = 5000; // Cost of Transfiguration

        // Ensure sufficient GP
        if (currentGP < cost) {
            console.log(`Insufficient GP for Transfiguration. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([
                new Date(), playerName, "GP", 0, "Transfiguration (Insufficient GP)"
            ]);
            return `You don't have enough GP for Transfiguration.`;
        }

        // Deduct GP
        gpTotalCell.setValue(currentGP - cost);

        // Log successful purchase
        gameFeedSheet.appendRow([
            new Date(), playerName, "GP", -cost, "Transfiguration Purchased"
        ]);

        console.log(`Transfiguration Activated for Player: ${playerName} (ID: ${uniqueId})`);
        return `Transfiguration Purchased! See the Game Master for your class change.`;
    } catch (error) {
        console.error(`Error in useTransfiguration: ${error.message}`, error.stack);
        return "An error occurred while activating Transfiguration.";
    }
}
function useDictator(uniqueId) {
  try {
    console.log(`useDictator called with Unique ID: ${uniqueId}`);
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
    const playerRow = findPlayerRowById(sheet, uniqueId);

    if (playerRow === -1) {
      console.error(`Player not found for Unique ID: ${uniqueId}`);
      return "Player not found.";
    }

    const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
    const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
    const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
    const currentGP = gpTotalCell.getValue() || 0;

    const cost = 500; // Cost of The Dictator
    if (currentGP < cost) {
      console.log(`Insufficient GP for The Dictator. Current GP: ${currentGP}`);
      gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "The Dictator (Insufficient GP)"]);
      return `You don't have enough GP for The Dictator.`;
    }

    // Deduct GP
    gpClearingCell.setValue(-cost);
    gpTotalCell.setValue(currentGP - cost);
    gpClearingCell.setValue(""); // Clear clearing house after processing

    // Compose dramatic message
const message = `The people have votedâ€¦ but ${playerName} has spoken. This week's review will be whatever the Dictator Wants!`;


    // Log to GameFeed
    gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, `The Dictator â€” ${message}`]);

    console.log(`The Dictator Activated for ${playerName}`);
    return message;
  } catch (error) {
    console.error(`Error in useDictator: ${error.message}`, error.stack);
    return "An error occurred while activating The Dictator.";
  }
}

function useAI(uniqueId) {
    try {
        console.log(`useAI called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 1000; // Cost of AI Feeder
        if (currentGP < cost) {
            console.log(`Insufficient GP for AI Feeder. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "AI Feeder (Insufficient GP)"]);
            return `You don't have enough GP for the AI Feeder.`;
        }

        // Deduct GP
        gpClearingCell.setValue(-cost); // Subtract GP in clearing house
        gpTotalCell.setValue(currentGP - cost); // Update GP total
        gpClearingCell.setValue(""); // Clear clearing house after processing

        console.log(`AI Feeder Activated for Player with Unique ID: ${uniqueId}`);
        
        // Log successful purchase
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "AI Feeder"]);
        return `AI Feeder Activated!`;
    } catch (error) {
        console.error(`Error in useAI: ${error.message}`, error.stack);
        return "An error occurred while activating the AI Feeder.";
    }
}
function useCollaborator(uniqueId) {
    try {
        console.log(`useCollaborator called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 500; // Cost of Collaborator
        if (currentGP < cost) {
            console.log(`Insufficient GP for Collaborator. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Collaborator (Insufficient GP)"]);
            return `You don't have enough GP for the Collaborator.`;
        }

        // Deduct GP
        gpClearingCell.setValue(-cost); // Subtract GP in clearing house
        gpTotalCell.setValue(currentGP - cost); // Update GP total
        gpClearingCell.setValue(""); // Clear clearing house after processing

        console.log(`Collaborator Activated for Player with Unique ID: ${uniqueId}`);
        
        // Log successful purchase
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Collaborator"]);
        return `Collaborator Activated!`;
    } catch (error) {
        console.error(`Error in useCollaborator: ${error.message}`, error.stack);
        return "An error occurred while activating the Collaborator.";
    }
}
function useBag(uniqueId) {
    try {
        console.log(`useBag called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const crystalClearingCell = sheet.getRange(playerRow, 11); // Column K: Crystals clearing house
        const crystalTotalCell = sheet.getRange(playerRow, 7); // Column G: Crystals total

        const currentGP = gpTotalCell.getValue() || 0;
        const currentCrystals = crystalTotalCell.getValue() || 0;

        const cost = 180; // Cost of the Bag of Crystals
        const addedCrystals = 1; // Amount of crystals added

        // Ensure sufficient GP
        if (currentGP < cost) {
            console.log(`Insufficient GP for Crystal bag. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Crystal bag (Insufficient GP)"]);
            return `You don't have enough GP for the Crystal bag.`;
        }

        // Deduct GP
        gpTotalCell.setValue(currentGP - cost);
        gpClearingCell.setValue(""); // Clear column L explicitly

        // Add Crystals
        crystalClearingCell.setValue(addedCrystals); // Trigger onEdit to process crystals
        const playerClass = sheet.getRange(playerRow, 2).getValue(); // Column B: Class

        // Enforce maximum Crystals
        const maxValues = {
            Healer: { health: 8, crystals: 5 },
            Mage: { health: 6, crystals: 6 },
            Guardian: { health: 10, crystals: 4 }
        };
        const maxCrystals = maxValues[playerClass]?.crystals || addedCrystals;
        const newCrystals = Math.min(currentCrystals + addedCrystals, maxCrystals);
        crystalTotalCell.setValue(newCrystals);
        crystalClearingCell.setValue(""); // Ensure column K is cleared after processing

        // Log actions
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Bag of Crystals"]);
        gameFeedSheet.appendRow([new Date(), playerName, "Crystals", newCrystals - currentCrystals, "Bag of Crystals"]);

        console.log(`Bag of Crystals Activated for Player with Unique ID: ${uniqueId}`);
        return `Bag of Crystals Activated!`;
    } catch (error) {
        console.error(`Error in useBag: ${error.message}`, error.stack);
        return "An error occurred while activating the Bag of Crystals.";
    }
}
function useFreedomPower(uniqueId) {
    try {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue();
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP total
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 1500; // Cost for Freedom Power
        if (currentGP < cost) {
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Freedom Power (Insufficient GP)"]);
            return "You don't have enough GP.";
        }

        // Deduct GP
        gpTotalCell.setValue(currentGP - cost);

        // Log the purchase in GameFeed
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Purchased Freedom Power"]);

        return "You have gained the power of Freedom!";
    } catch (error) {
        console.error(`Error in useFreedomPower: ${error.message}`);
        return "An error occurred.";
    }
}
function useLevelUp(uniqueId) {
    try {
        console.log(`useLevelUp called with Unique ID: ${uniqueId}`);
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            console.error(`Player not found for Unique ID: ${uniqueId}`);
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP total
        const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
        const xpTotalCell = sheet.getRange(playerRow, 5); // Column E: XP total

        const currentGP = parseInt(gpTotalCell.getValue(), 10) || 0;
        const currentXP = parseInt(xpTotalCell.getValue(), 10) || 0;

        const cost = 3000; // Cost of Level Up
        const addedXP = 1500; // Amount of XP added

        // Ensure sufficient GP
        if (currentGP < cost) {
            console.log(`Insufficient GP for Level Up. Current GP: ${currentGP}`);
            
            // Log insufficient GP attempt
            gameFeedSheet.appendRow([
                new Date(), playerName, "GP", 0, "Level Up (Insufficient GP)"
            ]);
            return `You don't have enough GP for Level Up.`;
        }

        // Deduct GP
        gpTotalCell.setValue(currentGP - cost);
        gpClearingCell.setValue(""); // Clear column L explicitly

        // Add XP directly to Column E (no column I involvement)
        xpTotalCell.setValue(currentXP + addedXP);

        // Log actions in GameFeed
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Level Up"]);
        gameFeedSheet.appendRow([new Date(), playerName, "XP", addedXP, "Level Up"]);

        // Run updatePlayerLevels() immediately to reflect level-up changes
        updatePlayerLevels();

        console.log(`Level Up Activated for Player: ${playerName} (ID: ${uniqueId})`);
        return `Level Up Activated! You've gained 1500 XP!`;
    } catch (error) {
        console.error(`Error in useLevelUp: ${error.message}`, error.stack);
        return "An error occurred while activating Level Up.";
    }
}


function useComingSoon(uniqueId) {
    try {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue();
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP total
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 1;
        if (currentGP < cost) {
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Coming Soon (Insufficient GP)"]);
            return "You don't have enough GP.";
        }

        gpTotalCell.setValue(currentGP - cost);
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Coming Soon"]);
        return "The Seller is bringing new items.";
    } catch (error) {
        console.error(`Error in useComingSoon: ${error.message}`);
        return "An error occurred.";
    }
}

function useShadowSwap(uniqueId) {
    try {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
        const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
        const playerRow = findPlayerRowById(sheet, uniqueId);

        if (playerRow === -1) {
            return "Player not found.";
        }

        const playerName = sheet.getRange(playerRow, 1).getValue();
        const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP total
        const currentGP = gpTotalCell.getValue() || 0;

        const cost = 333;
        if (currentGP < cost) {
            gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "Shadow Swap (Insufficient GP)"]);
            return "You don't have enough GP.";
        }

        // Deduct GP
        gpTotalCell.setValue(currentGP - cost);
        
        // Log the purchase
        gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "Shadow Swap"]);

        return "You have invoked the Shadow Swap!";
    } catch (error) {
        console.error(`Error in useShadowSwap: ${error.message}`);
        return "An error occurred.";
    }
}
function useTheTactician(uniqueId) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
  const gameFeedSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");

  const playerRow = findPlayerRowById(sheet, uniqueId);
  if (playerRow === -1) return "âŒ Player not found.";

  const playerName = sheet.getRange(playerRow, 1).getValue(); // Column A: Player Name
  const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: GP totals
  const gpClearingCell = sheet.getRange(playerRow, 12); // Column L: GP clearing house
  const currentGP = gpTotalCell.getValue() || 0;

  const cost = 600; // Cost of The Tactician

  if (currentGP < cost) {
    gameFeedSheet.appendRow([new Date(), playerName, "GP", 0, "The Tactician (Insufficient GP)"]);
    return "âŒ You don't have enough GP for The Tactician.";
  }

  // Deduct GP
  gpClearingCell.setValue(-cost); // Send deduction to the clearing house
  gpTotalCell.setValue(currentGP - cost); // Update GP total immediately
  gpClearingCell.setValue(""); // Clear the clearing house

  // Log to GameFeed
  gameFeedSheet.appendRow([new Date(), playerName, "GP", -cost, "The Tactician"]);

  return `The Tactician activated! You may now retry any one assignment.`;
}

function addGoldPieces(uniqueId, amount) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
    const playerRow = findPlayerRowById(sheet, uniqueId);
    if (playerRow === -1) return "Player not found.";

    const gpTotalCell = sheet.getRange(playerRow, 8); // Column H: Gold Pieces
    const currentGP = gpTotalCell.getValue() || 0;
    gpTotalCell.setValue(currentGP + amount);

    logGameAction(sheet.getRange(playerRow, 1).getValue(), "GP", amount, "Wheel of Destiny");
    return "GP added successfully.";
}

// Global variable to hold the latest 10 entries for the tickertape
const latestTickerData = []; // Holds the latest 19 entries for the tickertape

// Function to fetch the latest 10 entries from GameFeed
// Get latest 10 entries from GameFeed
function getLatestGameFeedEntries() {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
    if (!sheet) {
        console.error("GameFeed sheet not found.");
        return [];
    }

    const lastRow = sheet.getLastRow();
    const numEntries = 10;
    const startRow = Math.max(2, lastRow - numEntries + 1); // Prevent going above row 2 (headers)

    const data = sheet.getRange(startRow, 2, lastRow - startRow + 1, 9).getValues();
    console.log("Backend: Latest entries for tickertape:", data); // Debug log
    return data.reverse(); // Reverse to show most recent entries first
}

// Update tickertape data
function broadcastTickertapeUpdate(newData) {
    console.log("Backend: Broadcasting tickertape update:", newData); // Debug log
    latestTickerData.length = 0; // Clear old data
    latestTickerData.push(...newData); // Push new data
}

// Function to provide the latest tickertape data to the frontend
function getLiveTickerData() {
  console.log("Live ticker data:", latestTickerData); // Debug log
  console.log("Backend: Latest ticker data:", latestTickerData); // Debug log
    if (!latestTickerData.length) {
        // Fetch the initial data if ticker data is empty
        const initialData = getLatestGameFeedEntries();
        latestTickerData.push(...initialData);
    }
    console.log("Serving live ticker data:", latestTickerData); // Debug
    return latestTickerData;
}

// Function to delete GameFeed entries older than 10 days
function deleteOldLogEntries() {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");
    if (!sheet) {
        console.error("GameFeed sheet not found.");
        return;
    }

    const today = new Date();
    const lastRow = sheet.getLastRow();

    if (lastRow < 2) {
        console.log("No log entries to delete.");
        return;
    }

    const data = sheet.getRange(2, 1, lastRow - 1, 1).getValues(); // Column A contains timestamps
    const rowsToDelete = [];

    for (let i = 0; i < data.length; i++) {
        const logDate = new Date(data[i][0]);
        const diffInDays = (today - logDate) / (1000 * 60 * 60 * 24); // Convert milliseconds to days
        if (diffInDays > 10) {
            rowsToDelete.push(i + 2); // Add the row number (offset by 2 to account for the header)
        }
    }

    // Delete rows in reverse to avoid shifting row indices
    for (let i = rowsToDelete.length - 1; i >= 0; i--) {
        sheet.deleteRow(rowsToDelete[i]);
    }

    // âœ… Ensure the sheet always has at least 1000 rows after deletions
    if (sheet.getMaxRows() < 1000) {
        sheet.insertRowsAfter(sheet.getMaxRows(), 1000 - sheet.getMaxRows());
    }

    console.log(`Deleted ${rowsToDelete.length} old log entries.`);
}

function checkPlayerHealthAndAffectTeammates() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const xpSheet = ss.getSheetByName('XP, Mana, Health');
  const gameFeedSheet = ss.getSheetByName('GameFeed');
  const healthColumnIndex = 6;  // Column F (Heart Health Totals)
  const teamColumnIndex = 13;   // Column M (Team)
  const playerNameColumnIndex = 1;  // Column A (Player Name)
  const currentTime = new Date();

  const data = xpSheet.getRange(2, 1, xpSheet.getLastRow() - 1, xpSheet.getLastColumn()).getValues(); // Get all rows except headers
  const teamsMap = {};

  // Organize players by team
  data.forEach(row => {
    const playerName = row[playerNameColumnIndex - 1];
    const health = row[healthColumnIndex - 1];
    const team = row[teamColumnIndex - 1];

    if (team) {
      if (!teamsMap[team]) {
        teamsMap[team] = [];
      }
      teamsMap[team].push({ playerName, health });
    }
  });

  // Check each player's health and adjust teammates if necessary
  for (const [team, members] of Object.entries(teamsMap)) {
    for (const player of members) {
      if (player.health <= 0) {
        Logger.log(`${player.playerName} has fallen! Adjusting team ${team}...`);

        // Subtract 1 health from teammates, but not the fallen player
        members.forEach(teammate => {
          if (teammate.playerName !== player.playerName) {
            const rowIndex = data.findIndex(row => row[playerNameColumnIndex - 1] === teammate.playerName) + 2;
            const currentHealth = xpSheet.getRange(rowIndex, healthColumnIndex).getValue();

            if (currentHealth > 0) {
              xpSheet.getRange(rowIndex, healthColumnIndex).setValue(currentHealth - 1);  // Subtract 1 health
              gameFeedSheet.appendRow([
                currentTime,
                teammate.playerName,
                'Health',
                -1,
                'A Teammate Fell'
              ]);
            }
          }
        });
      }
    }
  }

  // Reset fallen players to 1 heart and log it
  data.forEach((row, index) => {
    const playerName = row[playerNameColumnIndex - 1];
    const health = row[healthColumnIndex - 1];

    if (health <= 0) {
      const rowIndex = index + 2;  // Adjust for header row
      xpSheet.getRange(rowIndex, healthColumnIndex).setValue(1);  // Reset health to 1
      gameFeedSheet.appendRow([
        currentTime,
        playerName,
        'Health',
        'Set to 1',
        `${playerName} Fell and was Respawned with 1 Heart`
      ]);
    }
  });
}

function updateCrystalExchangeRate() {
  const sheet = SpreadsheetApp.getActive().getSheetByName('Crystal Exchange');
  const today = new Date();
  const todayStr = Utilities.formatDate(today, Session.getScriptTimeZone(), 'yyyy-MM-dd');

  const lastRow = sheet.getLastRow();
  const lastRate = parseFloat(sheet.getRange(lastRow, 2).getValue());

  let newRate = lastRate;

  // Small random movement (Â±2 to Â±4 GP)
  const dailyChange = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 2 + 2);
  newRate += dailyChange;

  // Clamp to 120â€“150 GP range
  newRate = Math.max(120, Math.min(150, newRate));
  newRate = parseFloat(newRate.toFixed(2));

  // 2% chance of a crash or spike
  if (Math.random() < 0.02) {
    newRate = Math.random() < 0.5 ? 120 : 150;
  }

  // Write new rate only if today hasn't been logged
  const lastDate = sheet.getRange(lastRow, 1).getValue();
  const lastDateStr = Utilities.formatDate(new Date(lastDate), Session.getScriptTimeZone(), 'yyyy-MM-dd');

  if (lastDateStr !== todayStr) {
    sheet.appendRow([todayStr, newRate]);
  }
}


function buyOneCrystal(uniqueId) {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getSheetByName("XP, Mana, Health");
  const rateSheet = ss.getSheetByName("Crystal Exchange");

  const playerRow = findPlayerRowById(sheet, uniqueId);
  if (playerRow === -1) {
    Logger.log("âŒ Player not found for Unique ID: " + uniqueId);
    return "âŒ Player not found.";
  }

  const playerName = sheet.getRange(playerRow, 1).getValue();   // Column A
  const gp = sheet.getRange(playerRow, 8).getValue();           // Column H
  const vault = sheet.getRange(playerRow, 16).getValue() || 0;  // Column P (1-based index)
  const todayRate = rateSheet.getRange(rateSheet.getLastRow(), 2).getValue();

  if (gp < todayRate) {
    return "âŒ You don't have enough GP to buy a crystal.";
  }

  // Subtract GP, add to Vault
  sheet.getRange(playerRow, 8).setValue(parseFloat((gp - todayRate).toFixed(2))); // GP
  sheet.getRange(playerRow, 16).setValue(vault + 1); // Vault (Column P)

  logGameAction(playerName, "Vault", "'+1 (Buy)'", `@ ${todayRate} GP`);
  logGameAction(playerName, "Gold Pieces", "'â€“" + todayRate.toFixed(2) + " GP'", "Buy Crystal");

  return `âœ… Bought 1 Vaulted Crystal for ${todayRate.toFixed(2)} GP`;
}


function sellOneCrystal(uniqueId) {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getSheetByName("XP, Mana, Health");
  const rateSheet = ss.getSheetByName("Crystal Exchange");

  const playerRow = findPlayerRowById(sheet, uniqueId);
  if (playerRow === -1) return "âŒ Player not found.";

  const usableCrystals = sheet.getRange(playerRow, 7).getValue(); // Column G
  const gp = sheet.getRange(playerRow, 8).getValue();             // Column H
  const playerName = sheet.getRange(playerRow, 1).getValue();
  const rate = rateSheet.getRange(rateSheet.getLastRow(), 2).getValue();

  if (!usableCrystals || usableCrystals < 1) {
    return "âŒ You don't have any usable crystals to sell.";
  }

  // Subtract 1 from usable crystals (G), add GP (H)
  sheet.getRange(playerRow, 7).setValue(usableCrystals - 1);
  sheet.getRange(playerRow, 8).setValue(parseFloat((gp + rate).toFixed(2)));

  // Log the transaction
  logGameAction(playerName, "Crystals", "-1 (Sell)", `@ ${rate.toFixed(2)} GP`);
  logGameAction(playerName, "Gold Pieces", `+${rate.toFixed(2)} GP`, "Sell Crystal");

  return `âœ… Sold 1 crystal for ${rate.toFixed(2)} GP`;
}


function cashOutVaultedCrystals(uniqueId) {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getSheetByName("XP, Mana, Health");
  const rateSheet = ss.getSheetByName("Crystal Exchange");

  const playerRow = findPlayerRowById(sheet, uniqueId);
  if (playerRow === -1) {
    console.error(`Player not found for Unique ID: ${uniqueId}`);
    return "âŒ Player not found.";
  }

  const playerName = sheet.getRange(playerRow, 1).getValue();   // Column A
  const gp = sheet.getRange(playerRow, 8).getValue();           // Column H
  const vault = sheet.getRange(playerRow, 16).getValue() || 0;  // Column P
  const todayRate = rateSheet.getRange(rateSheet.getLastRow(), 2).getValue();

  if (vault <= 0) {
    return "âŒ No crystals in your vault to cash out.";
  }

  const gpEarned = parseFloat((vault * todayRate).toFixed(2));

  // Apply updates
  sheet.getRange(playerRow, 8).setValue(parseFloat((gp + gpEarned).toFixed(2))); // Add GP
  sheet.getRange(playerRow, 16).setValue(0); // Clear Vault

  logGameAction(playerName, "Vault", `'-${vault} Crystals'`, "Cashed Out");
  logGameAction(playerName, "Gold Pieces", `' +${gpEarned.toFixed(2)} GP'`, `@ ${todayRate} GP/Crystal`);

  return `âœ… You cashed out ${vault} Vaulted Crystals for ${gpEarned.toFixed(2)} GP`;
}

function getCrystalExchangeDataForPlayer(uniqueId) {
  Logger.log("ðŸ› ï¸ LIVE version of getCrystalExchangeDataForPlayer called");

  const ss = SpreadsheetApp.getActive();
  const xpSheet = ss.getSheetByName("XP, Mana, Health");
  const rateSheet = ss.getSheetByName("Crystal Exchange");

  const playerRow = findPlayerRowById(xpSheet, uniqueId);
  if (playerRow === -1) return null;

  const vault = xpSheet.getRange(playerRow, 16).getValue() || 0;

  // Get last 7 days â€” but guard against missing rows
  const lastRow = rateSheet.getLastRow();
  const startRow = Math.max(2, lastRow - 6);
  const rawRates = rateSheet.getRange(startRow, 1, lastRow - startRow + 1, 2).getValues();

  // Filter out any blank rows
  const rates = rawRates
    .filter(([date, rate]) => date && rate)
    .map(([date, rate]) => ({ date, rate }));

  Logger.log(`ðŸ“¦ Returning: vault=${vault}, rates=${JSON.stringify(rates)}`);

  const response = {
  vault: Number(vault),
  rates: rates.map(r => ({ date: String(r.date), rate: Number(r.rate) }))
};
Logger.log("âœ… Sending back clean response: " + JSON.stringify(response));
return response;

}
function logSpriteCatch(playerId) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("XP, Mana, Health");
  const gameFeed = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("GameFeed");

  const row = findPlayerRowById(sheet, playerId);
  if (row === -1) return "Player not found.";

  const playerName = sheet.getRange(row, 1).getValue(); // Column A = Player Name
  const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy/MM/dd HH:mm:ss");

  gameFeed.appendRow([timestamp, playerName, "GP", "+50 (Sprite Catch - Tell Mr.Watts)", "Sprite"]);

  return `${playerName} caught a sprite! (+50 GP pending)`;
}













