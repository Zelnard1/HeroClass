<!DOCTYPE html>
<!-- Crystal Exchange v2.3 live -->
<html>
<head>
    <title>Classcraft 2.0 Player Dashboard</title>
    <style>
        body { font-size: 18px; }
#content-box { width: 80%; margin: 0 auto; padding: 20px; }
table { width: 100%; border-collapse: collapse; margin: 0 auto; }
th, td { border: 1px solid #ddd; padding: 8px; text-align: left; font-size: 16px; }
th { background-color: #f2f2f2; font-size: 18px; }
h1 { font-size: 32px; text-align: center; }
#banner { width: 50%; margin: 20px auto; display: block; }
        
#universalPowers, #petFeedContainer {
    display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px; flex: 30%;
        }
#buttonContainer {
    display: flex;
    flex-wrap: nowrap; /* Prevent wrapping */
    justify-content: center; /* Center-align buttons */
    gap: 10px; /* Spacing between buttons */
    margin-top: 20px;
    flex-direction: row; /* Ensure single-row layout */
    margin-bottom: 50px; /* Add spacing below Class Powers buttons */
}

#button-image-layout {
    display: flex;
    flex-wrap: nowrap; /* Prevent wrapping */
    justify-content: center; /* Center-align buttons and image */
    gap: 10px; /* Spacing between elements */
    margin-top: 50px; /* Add spacing above the store buttons and image */
    flex-direction: row; /* Ensure single-row layout */
}
        .login-box input[type="password"],
#enterButton {
    margin: 0; /* Remove any default margins */
    margin-left: 10px; /* Add spacing between input and button */
    padding: 8px; /* Ensure consistent padding */
    height: 40px; /* Set a consistent height */
    font-size: 16px; /* Uniform font size */
    border: 2px solid #ccc; /* Matching borders */
    border-radius: 4px; /* Consistent rounded corners */
    box-sizing: border-box; /* Include padding in height/width */
    background-color: #007BFF; /* Button color */
    color: white; /* Text color */
    cursor: pointer; /* Enable pointer cursor */
    box-shadow: 0 1px #666; /* Slight shadow */
    transition: transform 0.1s, box-shadow 0.1s; /* Smooth transitions */
}

#enterButton:hover {
    background-color: #0056b3; /* Slightly darker on hover */
}

#enterButton:active {
    transform: scale(0.95); /* Shrink slightly when clicked */
    box-shadow: 0 1px #333; /* Reduce shadow depth */
}
/* Default Image Size for Larger Screens */
#playerImageContainer img {
    width: 140%;         /* width  */
    max-height: 800px;   /* Set the height */
    border-radius: 10px; /* Optional: rounded corners */
    margin: 0 auto;      /* Center the image horizontally */
    display: block;      /* Ensure the image behaves like a block element */
}

#playerImageContainer {
    flex: 0 0 30%;      /* Take up 30% of the width */
    text-align: center;
}

#rightPanel {
    flex: 0 0 65%;      /* Allow buttons to take up the rest */
    display: flex;
    flex-direction: column;  /* Stack buttons vertically */
    justify-content: center;
}


        /* Modal Overlay */
#modalOverlay {
    background: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 999; /* Keeps it above other content */
    display: none; /* Hidden by default */
}

/* Modal Notification Box */
#modalNotification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%); /* Centers the modal */
    background-color: #fff; /* White background */
    padding: 20px;
    border: 2px solid #000;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    z-index: 1000; /* Keeps it above the overlay */
    text-align: center;
    display: none; /* Hidden by default */
}

#modalNotification button {
    margin-top: 10px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    background-color: #007BFF;
    color: white;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: background-color 0.2s ease;
}

#modalNotification button:hover {
    background-color: #0056b3;
}
.login-box {
    display: flex; /* Align items horizontally */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Align items vertically */
    gap: 10px; /* Space between input and button */
    margin: 0 auto; /* Center horizontally */
    margin-bottom: 20px; /* Add space below the login box */
    width: auto; /* Adjust width dynamically */
}



#universalPowers {
    display: flex;
    flex-direction: column; /* Stack buttons vertically */
    align-items: center; /* Center align buttons */
    gap: 15px; /* Add spacing between buttons */
    margin-right: 20px; /* Space between universal powers and avatar */
}
#universalPowers, #petFeedContainer {
    display: flex;
    flex-direction: column; /* Stack items vertically */
    align-items: center;    /* Center items horizontally */
    gap: 20px;              /* Add spacing between buttons */
    margin-top: 20px;
}

#feedPetButton {
    width: 250px !important; /* Override .button width */
    height: 250px !important; /* Override .button height */
    border-radius: 20px;
    background-size: cover;
    background-position: center;
    border: 5px solid black;
    cursor: pointer;
    box-shadow: 0 10px #999;
    transition: transform 0.1s, box-shadow 0.1s;
}

#feedPetButton:hover {
    filter: brightness(1.2);
    transform: scale(1.05);
}

#feedPetButton:active {
    transform: scale(0.95); /* Shrinks slightly when clicked */
    box-shadow: 0 5px #666; /* Reduce shadow depth for pressed effect */
    filter: brightness(0.9); /* Slightly dims for pressed effect */
}

.button {
    width: 100px;
    height: 100px;
    border-radius: 12px;
    margin: 12px;
    background-size: cover;
    background-position: center;
    color: white;
    text-align: center;
    font-size: 12px;
    white-space: normal; /* Allow text wrapping */
    word-wrap: break-word; /* Force word wrapping */
    cursor: pointer;
    border: 5px solid black;
    box-shadow: 0 9px #999;
    transition: transform 0.1s, box-shadow 0.1s;
    display: flex; /* Flexbox for centering */
    align-items: center; /* Center text vertically */
    justify-content: center; /* Center text horizontally */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Improve readability */
    padding: 5px;
    line-height: 100px;
}


.button:hover {
    filter: brightness(1.2); 
    transform: scale(1.05); /* Slightly enlarges on hover */
}

.button:active {
    transform: scale(0.95); /* Shrinks slightly when clicked */
    box-shadow: 0 5px #666; /* Reduce shadow depth for pressed effect */
    filter: brightness(0.9); /* Slightly dims for pressed effect */
}

#separator-image-container {
    display: flex;
    justify-content: center; /* Center horizontally */
    margin-top: 20px; /* Add spacing above the image */
}

#separator-image {
    width: 80%; /* Adjust size as needed */
    max-width: 800px; /* Prevent it from becoming too large */
    border-radius: 10px; /* Optional: add rounded corners */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); /* Optional: add a shadow for better appearance */
}

.button-column {
    display: flex;
    flex-direction: column; /* Stack buttons vertically */
    align-items: center; /* Center buttons horizontally */
    gap: 15px; /* Add space between buttons */
}

#image-center {
    flex: 1; /* Allow the image to take up available space */
    display: flex;
    justify-content: center; /* Center the image horizontally */
}

.CaveatEmptor-button {
    width: 140px; 
    height: 140px; 
    border-radius: 15px; 
    margin: 15px; 
    background-size: cover; /* Ensure the image fills the button */
    background-position: center; /* Center the image */
    color: white;
    text-align: center; 
    font-size: 14px; /* Smaller default font size */
    line-height: normal; /* Ensures vertical centering */
    white-space: normal; /* Allows wrapping for long text */
    word-wrap: break-word; /* Forces wrapping on long words */
    cursor: pointer; 
    border: 5px solid gold; /* Gold border for store buttons */
    box-shadow: 0 9px #999; /* Shadow for depth */
    transition: transform 0.1s, box-shadow 0.1s, filter 0.1s; /* Smooth transitions */
    display: flex; /* Flexbox ensures better centering */
    align-items: center; /* Center vertically */
    justify-content: center; /* Center horizontally */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Adds readability */
}

.CaveatEmptor-button:hover {
    filter: brightness(1.2); /* Brighten on hover */
    transform: scale(1.05); /* Slightly enlarges the entire button */
    box-shadow: 0 6px #666; /* Slightly reduce shadow for pressed effect */
}

.CaveatEmptor-button:active {
    transform: scale(0.95); /* Shrinks slightly when clicked */
    box-shadow: 0 5px #333; /* Reduce shadow depth for pressed effect */
    filter: brightness(0.9); /* Slightly dims for pressed effect */
}

.close-button {
  float: right;
  font-size: 1.5em;
  font-weight: bold;
  cursor: pointer;
  color: #aaa;
}

.close-button:hover {
  color: #000;
}
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheel of Destiny</title>
    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        .image-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        .image-container img {
            margin: 0 20px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 200px;
        }
        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #wheelModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        #wheelModalContent {
            background-color: #fff;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }
/* Tickertape Settings */
#tickertape-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 30px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    overflow: hidden;
    z-index: 9999;
    display: flex;
    align-items: center;
}

#tickertape {
    white-space: nowrap;
    font-size: 16px;
    line-height: 30px;
    display: inline-flex;
    gap: 30px; /* Reduce gap for smoother scroll */
    transform: translateX(-100%);
    animation: ticker-scroll 50s linear infinite;
}

@keyframes ticker-scroll {
    from {
        transform: translateX(65%); /* Start slightly off-screen */
    }
    to {
        transform: translateX(-100%); /* End off-screen to the left */
    }
}

@media (max-width: 768px) {
    .button {
        width: 80px;
        height: 80px;
        font-size: 10px;
    }
    #buttonContainer {
        flex-wrap: wrap;
        gap: 8px; /* Adjust spacing for smaller screens */
    }

    /* Player Image and Container Adjustments for Small Screens */
    #playerImageContainer {
        flex: 1 1 100%;  /* Full width on small screens */
        margin-bottom: 10px;  /* Add space below the image */
    }

    #playerImageContainer img {
        max-height: 450px;  /* Slightly smaller for small screens (approx. 15cm) */
        width: auto;        /* Maintain aspect ratio */
        border-radius: 10px;  /* Optional: rounded corners */
    }

    #rightPanel {
        flex: 1 1 100%;  /* Full width for buttons container */
        margin-top: 10px;  /* Add space above the buttons */
    }
}
.loading {
    position: relative;
    pointer-events: none; /* Ensure no clicks during loading */
}

.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin-top: -10px;
    margin-left: -10px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}
#heal2-container {
    display: none; /* Hidden by default */
    width: 80%;
    margin: 20px auto; /* Center the container */
    background-color: #f9f9f9; /* Light background */
    border: 1px solid #ddd; /* Subtle border */
    border-radius: 10px; /* Rounded corners */
    padding: 20px; /* Spacing inside the container */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); /* Shadow for depth */
    text-align: center; /* Center the text and elements */
}

#heal2-container h2 {
    font-size: 24px; /* Larger heading */
    margin-bottom: 20px; /* Space below the heading */
}

#heal2-container select {
    width: 70%; /* Wide dropdown */
    padding: 10px; /* Padding for better appearance */
    font-size: 16px; /* Readable font size */
    border: 1px solid #ccc; /* Border style */
    border-radius: 5px; /* Rounded corners */
    margin-bottom: 20px; /* Space below the dropdown */
}

#heal2-container button {
    padding: 10px 20px; /* Button padding */
    font-size: 16px; /* Button text size */
    border: none; /* No border */
    border-radius: 5px; /* Rounded corners */
    background-color: #007BFF; /* Blue button background */
    color: white; /* White text */
    cursor: pointer; /* Pointer cursor on hover */
    transition: background-color 0.2s ease; /* Smooth hover effect */
}

#heal2-container button:hover {
    background-color: #0056b3; /* Darker blue on hover */
}

#heal2-container .close-button {
    float: right;
    font-size: 1.5em;
    font-weight: bold;
    cursor: pointer;
    color: #aaa;
}

#heal2-container .close-button:hover {
    color: #000;
}
#healTeammateButton {
    width: 160px; /* Increase width to fit longer text */
    height: 60px; /* Increase height for better readability */
    border-radius: 15px; /* Match the rounded corners with Caveat Emptor buttons */
    background-color: #007bff; /* Updated to blue to match the style */
    color: white; /* Keep text white for contrast */
    font-size: 18px; /* Increase font size for better readability */
    text-align: center;
    cursor: pointer;
    border: 3px solid gold; /* Gold border for consistency */
    box-shadow: 0 6px #666; /* Slightly deeper shadow for button effect */
    transition: transform 0.1s, box-shadow 0.1s; /* Smooth animation */
    display: flex; /* Flex to center content */
    align-items: center; /* Vertical centering */
    justify-content: center; /* Horizontal centering */
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Adds readability with slight shadow */
}

#healTeammateButton:hover {
    background-color: #0056b3; /* Slightly darker blue on hover */
}

#healTeammateButton:active {
    transform: scale(0.95); /* Shrink effect when clicked */
    box-shadow: 0 4px #444; /* Adjust shadow to pressed effect */
}
.floating-sprite-button {
  position: absolute;
  width: 80px;
  height: 80px;
  padding: 0;
  margin: 0;
  border: none;
  background: none;
  cursor: pointer;
  z-index: 9999;
  animation: float-across 12s linear forwards;
}

.floating-sprite-button img {
  width: 100%;
  height: 100%;
  display: block;
  pointer-events: none; /* So clicks register on the button, not the image */
}

@keyframes float-across {
  0%   { top: 50%; left: -100px; opacity: 0; }
  10%  { opacity: 1; }
  90%  { opacity: 1; }
  100% { top: 30%; left: 110%; opacity: 0; }
}


    </style>
</head>

<body>
    <div id="content-box">
    <img id="banner" src="https://i.imgur.com/DaMe9lH.jpg" alt="Classcraft Banner">
    <h1>Classcraft 2.0 Player Dashboard</h1>
    
    <!-- Login -->
    <div class="login-box">
    <input type="password" id="uniqueId" placeholder="Enter Unique ID">
    <button id="enterButton" onclick="getPlayerInfo()">Enter</button>
</div>


    <!-- Display Sections -->
    <div id="dataDisplay"></div>
    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
        <div id="playerImageContainer" style="flex: 1; text-align: center;"></div>
        <div id="rightPanel">
            <div id="universalPowers"></div> <!-- Universal Powers -->
            <div id="petFeedContainer"></div> <!-- Feed Pet Button -->
        </div>
    </div>

    <!-- Class Powers -->
    <div id="buttonContainer"></div> 


<!-- 💎 Crystal Exchange Section (Side-by-Side Layout) -->
<div id="crystal-exchange-section"
     style="display: none; gap: 20px; max-width: 1000px; margin: 20px auto;">

  <!-- 📊 Left: Info Panel -->
  <div id="crystal-exchange-display" style="flex: 1;">
    <h2 style="text-align: center;">💎 Crystal Exchange</h2>
    <p><strong>Today's Rate:</strong> <span id="crystal-rate">Loading...</span></p>
    
    <!-- 🟦 Chart container with fixed height -->
    <div style="width: 100%; height: 200px;">
      <canvas id="rateChart" style="width: 100%; height: 100%;"></canvas>
    </div>
    
    <p style="margin-top: 12px;"><strong>Your Vault:</strong> <span id="vault-count">Login to see</span></p>
    <p id="market-flavor" style="font-size: 12px; color: gray;">Loading market trend...</p>
  </div>

  <!-- 🪙 Crystal Exchange Buttons -->
<div id="crystal-exchange-buttons" style="display: flex; justify-content: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
  <div class="store-item">
    <button class="CaveatEmptor-button" onclick="buyOneCrystal()" style="background-image: url('https://imgur.com/Hib67Ya.jpg');">
      💰 Buy 1 Crystal
    </button>
  </div>
  <div class="store-item">
    <button class="CaveatEmptor-button" onclick="sellOneCrystal()" style="background-image: url('https://imgur.com/YXgoXJo.jpg');">
      💎 Sell Usable Crystal
    </button>
  </div>
  <div class="store-item">
    <button class="CaveatEmptor-button" onclick="cashOutVault()" style="background-image: url('https://imgur.com/M1Y0OKy.jpg');">
      💸 Cash Out Vault
    </button>
  </div>
</div>


</div>




    <!-- Store Section -->
<div id="button-image-section" style="display: none;">
    <div id="button-image-layout">
        <!-- Left side buttons -->
        <div id="left-buttons" class="button-column"></div>

        <!-- Center image -->
        <div id="image-center">
            <img id="separator-image" src="https://i.imgur.com/1NRHYSh.jpg" alt="Separator Image">
        </div>

        <!-- Right side buttons -->
        <div id="right-buttons" class="button-column"></div>
        
    </div>

</div>
        <!-- Modal Notification -->
        <div id="modalOverlay" style="display: none;"></div>
        <div id="modalNotification" style="display: none;">
            <p id="modalMessage"></p>
            <button onclick="closeModal()">OK</button>
        </div>
        
    </div>
<div id="wheel-destiny-container" style="display: none; text-align: center; margin-top: 20px;">
  <h1>Wheel of Destiny</h1>
  <p>You have bought a game of chance. If you match the two Mage Crystals, you win 1000 GP.</p>

  <div class="image-container" style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
    <img id="initialRandomImage" src="" alt="Initial Image" style="max-width: 45%; border: 2px solid black;">
    <img id="randomImage" src="" alt="Random Image" style="max-width: 45%; border: 2px solid black;">
  </div>

  <br>
  
  <button id="spinWheelButton" onclick="spinWheel()">Spin the Wheel</button>
  <button id="closeButton" onclick="closeWheelGame()">Close</button>
  
  <p id="matchMessage" style="margin-top: 15px; font-size: 18px; font-weight: bold;"></p>
  
  <div id="wheelModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);">
    <div id="wheelModalContent">
      <h3>Congratulations!</h3>
      <p>You matched the images and won 1000 GP!</p>
      <button onclick="closeWheelModal()">Close</button>
    </div>
  </div>
</div>
<!-- Heal 2 -->
<div id="heal2-container" style="display: none; text-align: center;">
  <h2>Heal 2</h2>
  <p>Select a teammate to heal or choose yourself:</p>
  <select id="teammateDropdown"></select>
  <button id="healTeammateButton" onclick="applyHeal2()">Heal</button>
  <p id="heal2Feedback"></p>
</div>

<!-- Revive -->
<div id="revive-container" style="display: none; text-align: center;">
  <h2>Revive</h2>
  <p>Select a teammate to revive:</p>
  <select id="reviveDropdown"></select>
  <button id="reviveTeammateButton" onclick="applyRevive()">Revive</button>
  <p id="reviveFeedback"></p>
</div>


<div id="tickertape-container" 
    style="overflow: hidden; white-space: nowrap; position: fixed; top: 0; left: 0; width: 100%; background: black; color: white; z-index: 9999; padding: 10px 0;">
    <div id="tickertape" 
        style="position: absolute; white-space: nowrap; font-size: 16px; line-height: 40px; padding: 10px;">
        <!-- Example Tickertape Content -->
        <span class="tickertape-item">Latest News</span>
        <span class="tickertape-item">|</span>
        <span class="tickertape-item">Breaking</span>
        <span class="tickertape-item">|</span>
        <span class="tickertape-item">Latest News</span>
        <span class="tickertape-item">|</span>
    </div>
</div>
</div>
<!-- Load Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        let storedUniqueId = "";
let exchangeLoaded = false;
        const powerLevels = {
    Healer: [
        { level: 2, id: "useHeal1Button", name: "Heal 1", imageUrl: "https://i.imgur.com/mgo8Qbw.jpg" },
        { level: 4, id: "useRespiteButton", name: "Respite", imageUrl: "https://i.imgur.com/VFmX8ER.jpg" },
        { level: 5, id: "useArdentFaithButton", name: "Ardent Faith", imageUrl: "https://i.imgur.com/BqaCOmW.jpg" },
        { level: 8, id: "useReviveButton", name: "Revive", imageUrl: "https://i.imgur.com/620QCgH.jpg" },
        { level: 10, id: "useFavourOfTheGodsButton", name: "Favour of the Gods", imageUrl: "https://i.imgur.com/I8XquVl.jpg" },
        { level: 15, id: "useHeal2Button", name: "Heal 2", imageUrl: "https://i.imgur.com/OwHPHyq.jpg" },
        { level: 20, id: "useHealingCircleButton", name: "Healing Circle", imageUrl: "https://i.imgur.com/2jkaEk3.jpg" },
        { level: 24, id: "useHeal3Button", name: "Heal 3", imageUrl: "https://i.imgur.com/0WEYbUM.jpg" },
        { level: 28, id: "usePrayerButton", name: "Prayer", imageUrl: "https://i.imgur.com/iIVx4Kp.jpg" }
        
    ],
    Guardian: [
        { level: 2, id: "useGuard1Button", name: "Guard 1", imageUrl: "https://i.imgur.com/RXPXhFH.jpg" },
        { level: 4, id: "useFrontalAssaultButton", name: "Frontal Assault", imageUrl: "https://i.imgur.com/dhSEBTi.jpg" },
        { level: 5, id: "useFirstAidButton", name: "First Aid", imageUrl: "https://i.imgur.com/syUEg9Q.jpg" },
        { level: 8, id: "useCounterAttackButton", name: "Counter Attack", imageUrl: "https://i.imgur.com/xkG7tAk.jpg" },
        { level: 10, id: "useGuard2Button", name: "Guard 2", imageUrl: "https://i.imgur.com/xy72uHO.jpg" },
        { level: 15, id: "useFrontalAssault2Button", name: "Frontal Assault 2", imageUrl: "https://i.imgur.com/dhSEBTi.jpg" },
        { level: 20, id: "useDefenseOfTheCastleButton", name: "Defense of the Castle", imageUrl: "https://i.imgur.com/JV0ec5r.jpg" },
        { level: 24, id: "useGuardAllButton", name: "Guard All", imageUrl: "https://i.imgur.com/nrHSOb0.jpg" },
        { level: 28, id: "useSecretWeaponButton", name: "Secret Weapon", imageUrl: "https://i.imgur.com/jSs9NWo.jpg" }
    ],
    Mage: [
        { level: 2, id: "useCrystalTransferButton", name: "Crystal Transfer", imageUrl: "https://i.imgur.com/7DJFaVr.jpg" },
        { level: 4, id: "useGenerosityAndSacrifice", name: "Generosity and Sacrifice", imageUrl: "https://i.imgur.com/X6oIDTD.jpg" },
        { level: 6, id: "useTheCall", name: "The Call", imageUrl: "https://i.imgur.com/PHupIef.jpg" },
        { level: 8, id: "useTeleport", name: "Teleport", imageUrl: "https://i.imgur.com/Nxy2oSi.jpg" },
        { level: 10, id: "useManaShield", name: "Mana Shield", imageUrl: "https://i.imgur.com/lrfCdi5.jpg" },
        { level: 15, id: "useClairvoyance", name: "Clairvoyance", imageUrl: "https://i.imgur.com/JXk95JK.jpg" },
        { level: 20, id: "useCheatDeath", name: "Cheat Death", imageUrl: "https://i.imgur.com/7fic1U9.jpg" },
        { level: 24, id: "useTimeWarp", name: "Time Warp", imageUrl: "https://i.imgur.com/FiSsHI5.jpg" },
        { level: 28, id: "useCrystalManaFountain", name: "Crystal Mana Fountain", imageUrl: "https://i.imgur.com/sl9OCgG.jpg" },
        { level: 30, id: "useMageCircle", name: "Mage Circle", imageUrl: "https://i.imgur.com/l3QHe5b.jpg" }
    ]
};




function getPlayerInfo() {
  const uniqueId = document.getElementById('uniqueId').value;
  if (!uniqueId) return alert("Please enter a Unique ID.");
  storedUniqueId = uniqueId;

  google.script.run.withSuccessHandler(data => {
    if (data) {
      showData(data);
      document.getElementById("button-image-section").style.display = "block";
      renderStoreItems();

      // ✅ Show the Crystal Exchange section after login
      document.getElementById("crystal-exchange-section").style.display = "block";

          // ✅ Load crystal exchange data AFTER successful login
      google.script.run
        .withSuccessHandler(renderCrystalExchangeDisplay)
        .getCrystalExchangeDataForPlayer(storedUniqueId);
        console.log("📦 Sending storedUniqueId:", storedUniqueId);

    } else {
      alert("Player data not found. Please check your ID.");
    }
  }).getPlayerData(uniqueId);
}



        // Show Data and Buttons
        function showData(data) {
            if (!data) return alert("Player data not found.");
            displayPlayerTable(data);
            displayPlayerImage(data);
            displayClassPowers(data.characterClass, data.level);
            displayUniversalPowers();
            displayPetFeedButton();
        }

        function displayPlayerTable(data) {
    const display = document.getElementById('dataDisplay');
    const titles = {
        playerName: "Player",
        characterClass: "Character Class",
        level: "Level",
        xp: "XP",
        health: "Health",
        crystals: "Crystals",
        goldPieces: "Gold Pieces"
    };

    let content = '<table><tr><th>Title</th><th>Information</th></tr>';
    for (const key in titles) {
        if (data[key] !== undefined) {
            content += `<tr><td>${titles[key]}</td><td>${data[key]}</td></tr>`;
        }
    }
    content += '</table>';
    display.innerHTML = content;
}


        function displayPlayerImage(data) {
            const container = document.getElementById('playerImageContainer');
            container.innerHTML = data.imageUrl
                ? `<img src="${data.imageUrl}" class="player-image" alt="Player Image">`
                : "<p>No image available</p>";
        }

        function displayClassPowers(characterClass, level) {
    const container = document.getElementById('buttonContainer');
    container.innerHTML = ""; // Clear any existing buttons

    const powers = powerLevels[characterClass] || []; // Get powers for the class

    powers.forEach(power => {
        if (level >= power.level) {
            const button = document.createElement('button');
            button.id = power.id; // Set button ID
            button.className = "button";
            button.style.backgroundImage = `url('${power.imageUrl}')`;
            button.innerText = power.name;

            // Use the same triggerPower function as universal powers
            button.onclick = () => {
                triggerPower(power.id, getPowerCost(power.id), `${power.name} Activated!`, power.name);
            };

            container.appendChild(button);
        }
    });
}


        function displayUniversalPowers() {
    const container = document.getElementById('universalPowers');
    container.innerHTML = ""; // Clear existing content

    const universalPowers = [
        { id: "useInvisibilityButton", name: "Invisibility", cost: 1, imageUrl: "https://i.imgur.com/ASC6Gpn.jpg" },
        { id: "useForageButton", name: "Forage", cost: 1, imageUrl: "https://i.imgur.com/jIaIPR5.jpg" },
        { id: "useSainthoodButton", name: "Sainthood", cost: 2, imageUrl: "https://i.imgur.com/l3QHe5b.jpg" }
    ];

    universalPowers.forEach(power => {
        const button = document.createElement('button');
        button.id = power.id; // Set button ID
        button.className = "button";
        button.style.backgroundImage = `url('${power.imageUrl}')`;
        button.innerText = power.name;

        // Universal button onclick handler
        button.onclick = () => {
            triggerPower(power.id, power.cost, `${power.name} Activated!`, power.name);
        };

        container.appendChild(button);
    });
}


        function displayPetFeedButton() {
    const container = document.getElementById('petFeedContainer');
    container.innerHTML = `<h3>Feed Your Pet</h3>
        <button class="button" id="feedPetButton" onclick="feedPet()"></button>`;
    google.script.run.withSuccessHandler(imageUrl => {
        document.getElementById('feedPetButton').style.backgroundImage = `url('${imageUrl}')`;
    }).getPetImage();
}





function feedPet() {
    const button = document.getElementById('feedPetButton');
    if (!button) return; // Safety check

    // Add loading class and disable button
    button.classList.add('loading');
    button.disabled = true;

    console.log("Calling addPetFeedPoint with ID:", storedUniqueId);

    google.script.run
        .withSuccessHandler(responseMessage => {
            console.log("Response from addPetFeedPoint:", responseMessage);
            showModal(responseMessage); // Show the actual response message
            refreshTable(); // Refresh player data

            // Remove loading class and re-enable button
            button.classList.remove('loading');
            button.disabled = false;
        })
        .withFailureHandler(error => {
            console.error("Error in addPetFeedPoint:", error.message);
            showModal("An error occurred while feeding your pet.");

            // Remove loading class and re-enable button
            button.classList.remove('loading');
            button.disabled = false;
        })
        .addPetFeedPoint(storedUniqueId); // Correct backend function name
}


// Debugging Updates for Modal
function showModal(message) {
    console.log("Displaying modal with message:", message);
    const modalOverlay = document.getElementById('modalOverlay');
    const modalNotification = document.getElementById('modalNotification');
    const modalMessage = document.getElementById('modalMessage');

    modalMessage.innerText = message; // Update modal message
    modalOverlay.style.display = 'block';
    modalNotification.style.display = 'block';
}
function closeModal() {
    document.getElementById('modalOverlay').style.display = 'none';
    document.getElementById('modalNotification').style.display = 'none';
}

function refreshTable() {
    google.script.run.withSuccessHandler(showData).getPlayerData(storedUniqueId);
}

// Client-Side Power Costs
const powerCosts = {
    useHeal1Button: 1,
    useRespiteButton: 2,
    useArdentFaithButton: 2,
    useReviveButton: 2,
    useFavourOfTheGodsButton: 2,
    useHeal2Button: 2,
    useHealingCircleButton: 3,
    useHeal3Button: 3,
    usePrayerButton: 4,
    useCrystalTransferButton: 3,
    useGuard1Button: 1,
    useFrontalAssaultButton: 2,
    useFirstAidButton: 2,
    useCounterAttackButton: 3,
    useGuard2Button: 2,
    useFrontalAssault2Button: 4,
    useDefenseOfTheCastleButton: 4,
    useGuardAllButton: 3,
    useSecretWeaponButton: 4,
    useGenerosityAndSacrifice: 2,
    useTheCall: 2,
    useTeleport: 2,
    useManaShield: 2,
    useClairvoyance: 3,
    useCheatDeath: 2,
    useTimeWarp: 2,
    useCrystalManaFountain: 4,
    useMageCircle: 4
};

// Client-Side Function to Get Power Cost
function getPowerCost(powerId) {
    return powerCosts[powerId] || 0; // Return 0 if the powerId is not found
}
// Active powers tracking set
const activePowers = new Set();

function triggerPower(powerId, cost, successMessage, powerName) {
    console.log("Inside triggerPower, Store Items:", storeItems);

    if (!storedUniqueId) {
        showModal("Please log in first.");
        return;
    }

    setLoading(powerId, true); // Start loading animation

    const storeItem = storeItems.find(item => item.id === powerId);
    const isStoreItem = !!storeItem;
console.log(`Checking if ${powerId} is a store item:`, isStoreItem);
    google.script.run.withSuccessHandler(playerData => {
        const currency = isStoreItem ? "goldPieces" : "crystals";
        const hasEnoughCurrency = isStoreItem
            ? playerData.goldPieces >= cost
            : playerData.crystals >= cost;

        if (hasEnoughCurrency) {
            let backendFunction;

            // Handle "Wheel of Destiny" purchase and spin
if (powerId === "useWheelButton") {
    console.log("Processing Wheel of Destiny in triggerPower.");
    hasPaidForWheel = true; // Mark that the player paid
    console.log("Wheel spin purchased, hasPaidForWheel set to:", hasPaidForWheel);

    google.script.run
        .withSuccessHandler(response => {
            console.log(`Backend response for Wheel: ${response}`);
            const data = typeof response === "string" ? JSON.parse(response) : response;

            if (data.success) {
                showModal("Wheel of Destiny Purchased!");
                refreshTable();  // Refresh after GP deduction for purchase
                setTimeout(() => showWheelGame(), 200); // Show the Wheel after a short delay
            } else {
                showModal(data.message || "An error occurred.");
            }

            setLoading(powerId, false); // Stop loading animation
        })
        .withFailureHandler(error => {
            console.error("Error in Wheel of Destiny:", error);
            showModal("An error occurred while processing Wheel of Destiny.");
            setLoading(powerId, false);
        })
        .useWheel(storedUniqueId); // Call the backend `useWheel` function

    return; // Prevent further execution
}

            // Store items route
            if (isStoreItem) {
                backendFunction = 
                    powerId === "useTinkererButton" ? "useTinkerer" :
                    powerId === "usePlannerButton" ? "usePlanner" :
                    powerId === "useDealButton" ? "useDeal" :
                    powerId === "useAIButton" ? "useAI" :
                    powerId === "useCollaboratorButton" ? "useCollaborator" :
                    powerId === "useBagButton" ? "useBag" :
                    powerId === "useFreedomPowerButton" ? "useFreedomPower" :
                    powerId === "useShadowSwapButton" ? "useShadowSwap" :
                    powerId === "useLevelUpButton" ? "useLevelUp" :
                    powerId === "useTransfigurationButton" ? "useTransfiguration" :
                    powerId === "useDictatorButton" ? "useDictator" :
                    powerId === "useTheTacticianButton" ? "useTheTactician" :
                    powerId === "useComingSoonButton" ? "useComingSoon" :
                    null;

                console.log(`Backend Function for ${powerId}: ${backendFunction}`);
            } else {
                switch (powerId) {
                    case "useHeal2Button": showHeal2Container(); return;
                    case "useHeal3Button": showHeal3Container(); return;
                    case "useGuard1Button": showGuard1Container(); return;
                    case "useGuard2Button": showGuard2Container(); return;
                    case "useReviveButton": showReviveContainer(); return; // This line for Revive
                    case "useGuardAllButton":
                        if (activePowers.has(powerId)) {
                            console.warn(`${powerId} is already active.`);
                            return;
                        }
                        activePowers.add(powerId);
                        google.script.run
                            .withSuccessHandler(message => {
                                activePowers.delete(powerId);
                                setLoading(powerId, false);
                                showModal(message);
                                refreshTable();
                            })
                            .withFailureHandler(error => {
                                activePowers.delete(powerId);
                                setLoading(powerId, false);
                                showModal("An error occurred while using Guard All.");
                            })
                            .useGuardAllButton(storedUniqueId);
                        return;
                    default:
                        backendFunction = powerId; // Use the powerId as the backend function by default
                        break;
                }
            }

            if (!backendFunction) {
                showModal("Invalid power triggered.");
                activePowers.delete(powerId);
                setLoading(powerId, false);
                return;
            }

            google.script.run.withSuccessHandler(response => {
                showModal(response.includes("Failed") ? response : successMessage);
                refreshTable();
                activePowers.delete(powerId);
                setLoading(powerId, false);
            }).withFailureHandler(error => {
                showModal("An error occurred while activating the power.");
                activePowers.delete(powerId);
                setLoading(powerId, false);
            })[backendFunction](storedUniqueId);
        } else {
            showModal(`You don't have enough ${isStoreItem ? "GP" : "Crystals"} for ${powerName}.`);
            activePowers.delete(powerId);
            setLoading(powerId, false);
        }
    }).withFailureHandler(() => {
        showModal("An error occurred while fetching player data.");
        activePowers.delete(powerId);
        setLoading(powerId, false);
    }).getPlayerData(storedUniqueId);
}




// Add the function to display a random Wheel of Destiny image
function displayRandomWheelImage() {
    const randomImageElement = document.getElementById("randomImage");
    if (!randomImageElement) {
        console.error("Random image element not found.");
        return;
    }

    if (!wheelData || wheelData.length === 0) {
        console.error("Wheel data is not loaded or empty.");
        return;
    }

    const randomImage = wheelData[Math.floor(Math.random() * wheelData.length)].url;
    console.log("Selected Random Wheel Image:", randomImage);

    randomImageElement.src = randomImage; // Update the random image
    document.getElementById("wheel-destiny-container").style.display = "block"; // Show the container
}

const storeItems = [
    { id: "useTinkererButton", name: "Tinkerer", cost: 900, imageUrl: "https://i.imgur.com/jOVfq0C.jpg" },
    { id: "usePlannerButton", name: "The Planner", cost: 500, imageUrl: "https://imgur.com/MuL7Hzo.jpg" },
    { id: "useDealButton", name: "Deal", cost: 600, imageUrl: "https://imgur.com/L3utdnB.jpg" },
    { id: "useWheelButton", name: "Wheel Of Destiny", cost: 100, imageUrl: "https://imgur.com/PZ6z2ul.jpg" },
    { id: "useAIButton", name: "AI Feeder", cost: 1000, imageUrl: "https://imgur.com/Uk2AeuX.jpg" },
    { id: "useCollaboratorButton", name: "Collaborator", cost: 500, imageUrl: "https://imgur.com/PBJGkrM.jpg" },
    { id: "useBagButton", name: "Crystal Bag", cost: 180, imageUrl: "https://imgur.com/D4PrsnK.jpg" },
    { id: "useFreedomPowerButton", name: "Freedom Power", cost: 1500, imageUrl: "https://imgur.com/rZu7wcB.jpg" },
    { id: "useShadowSwapButton", name: "Shadow Swap", cost: 333, imageUrl: "https://imgur.com/9jXodGq.jpg" },
    { id: "useLevelUpButton", name: "Level Up", cost: 3000, imageUrl: "https://imgur.com/JjuWbL8.jpg" },
    { id: "useTransfigurationButton", name: "Transfiguration", cost: 5000, imageUrl: "https://imgur.com/NY2hbLI.jpg" },
    { id: "useDictatorButton", name: "The Dictator", cost: 500, imageUrl: "https://imgur.com/CCJaazz.jpg" },
    { id: "useTheTacticianButton", name: "The Tactician", cost: 600, imageUrl: "https://imgur.com/vF5Nbn2.jpg" },
    { id: "useComingSoonButton", name: "Coming Soon", cost: 1, imageUrl: "https://imgur.com/0b4kGQW.jpg" }
];



console.log("Store Items:", storeItems); // Debugging storeItems

// Now define renderStoreItems and other functions
function renderStoreItems() {
    console.log("Rendering store items:", storeItems); // Debugging

    const leftButtons = document.getElementById("left-buttons");
    const rightButtons = document.getElementById("right-buttons");

    if (!leftButtons || !rightButtons) {
        console.error("Store button containers not found.");
        return;
    }

    // Clear previous buttons
    leftButtons.innerHTML = "";
    rightButtons.innerHTML = "";

    storeItems.forEach((item, index) => {
        const button = document.createElement("button");
        button.id = item.id;
        button.className = "CaveatEmptor-button";
        button.style.backgroundImage = item.imageUrl ? `url('${item.imageUrl}')` : "none";
        button.textContent = item.name;

        // Attach click handler dynamically
        button.onclick = () => {
            triggerPower(item.id, item.cost, `${item.name} Purchased!`, item.name);
        };

        // Balance placement: Alternating left & right sides
        if (index % 2 === 0) {
            leftButtons.appendChild(button);
        } else {
            rightButtons.appendChild(button);
        }
    });
}

// Load image data from the server
// Check if imageData is valid before initializing wheelData
const imageData = JSON.parse('<?= imageData ?>');
if (!imageData || !Array.isArray(imageData) || imageData.length === 0) {
    console.error("imageData is invalid or empty.");
} else {
    console.log("Loaded imageData:", imageData);
}
const wheelData = imageData;
const imageUrls = wheelData.map(item => item.url);

let initialImage = "";
let hasPaidForWheel = false; // State variable to track if the player has paid
console.log("hasPaidForWheel updated to:", hasPaidForWheel);

// Display a random wheel crystal image on page load
function displayInitialRandomImage() {
    const initialImageElement = document.getElementById("initialRandomImage");
    if (!initialImageElement) {
        console.error("Initial random image element not found.");
        return;
    }

    if (!wheelData || wheelData.length === 0) {
        console.error("Wheel data is not loaded or empty.");
        return;
    }

    const randomIndex = Math.floor(Math.random() * imageUrls.length);
    initialImage = imageUrls[randomIndex];
    console.log("Selected Initial Random Image:", initialImage);
    initialImageElement.src = initialImage;
}


function purchaseWheelSpin() {
    google.script.run.withSuccessHandler(response => {
        const data = JSON.parse(response);
        if (data.success) {
            hasPaidForWheel = true; // Update the state
            console.log("Wheel spin purchased, hasPaidForWheel set to:", hasPaidForWheel); // Debug log
            showModal(data.message); // Show confirmation modal
            showWheelGame(); // Display the game
        } else {
            console.log("Purchase failed:", data.message);
            showModal(data.message); // Show error message
        }
    }).useWheel(storedUniqueId);
}




// Function to show the Wheel of Destiny game
function showWheelGame() {
    console.log("Entering showWheelGame. Current state of hasPaidForWheel:", hasPaidForWheel);

    const wheelContainer = document.getElementById("wheel-destiny-container");
    if (!wheelContainer) {
        console.error("Wheel of Destiny container not found.");
        return;
    }

    if (!hasPaidForWheel) {
        console.warn("Attempted to show Wheel without purchase. hasPaidForWheel:", hasPaidForWheel);
        showModal("You must purchase a Wheel of Destiny spin first.");
        return;
    }

    // Clear the match message before starting a new game
    const matchMessage = document.getElementById("matchMessage");
    if (matchMessage) {
        matchMessage.textContent = ""; // Clear the previous message
    }

    wheelContainer.style.display = "block";
    displayInitialRandomImage(); // Ensure the initial image is shown
    console.log("Wheel game displayed successfully.");
}




// Function to spin the wheel and display a random image
function spinWheel() {
    console.log("Spinning the Wheel. hasPaidForWheel:", hasPaidForWheel); // Debug log
    if (!hasPaidForWheel) {
        showModal("You need to purchase a spin first!"); // Custom modal message
        return;
    }

    const randomIndex = Math.floor(Math.random() * imageUrls.length);
    const selectedImage = imageUrls[randomIndex];
    document.getElementById("randomImage").src = selectedImage;

    // Check for a match
    if (initialImage === selectedImage) {
        showModal("Congratulations! You win 1000 GP.");
        google.script.run
            .withSuccessHandler(() => {
                console.log("GP added successfully!");
                refreshTable();  // Attempt to refresh table inside the success handler
            })
            .withFailureHandler(error => {
                console.error("Error adding GP:", error);
                showModal("An error occurred while adding GP.");
            })
            .addGoldPieces(storedUniqueId, 1000); // Backend call to add GP
    } else {
        document.getElementById("matchMessage").textContent = "Unlucky, try again!";
    }

    // Reset `hasPaidForWheel` after spin
    hasPaidForWheel = false;
    console.log("hasPaidForWheel reset to:", hasPaidForWheel);

    // Ensure a refresh attempt after the spin regardless of outcome
    setTimeout(refreshTable, 500);  // Additional refresh attempt after a short delay
}



// Function to close the game and reset
function closeWheelGame() {
    const wheelContainer = document.getElementById("wheel-destiny-container");
    if (wheelContainer) {
        wheelContainer.style.display = "none";
    }

    hasPaidForWheel = false; // Reset payment state
    displayInitialRandomImage(); // Reset the initial image for a new game

    // Clear the match message to prepare for a new game
    const matchMessage = document.getElementById("matchMessage");
    if (matchMessage) {
        matchMessage.textContent = ""; // Clear the message on close
    }
}


    let tickerData = []; // Holds the latest GameFeed data
const tickertapeElement = document.getElementById('tickertape');
const tickertapeContainer = document.getElementById('tickertape-container');

// Fetch data from the backend
function fetchTickertapeData() {
    google.script.run.withSuccessHandler(updateTickertape).getLatestGameFeedEntries(); // Fetch last 5 entries
}

function updateTickertape(data) {
    console.log("Received tickertape data:", data);

    // Update tickerData only if it has changed
    if (JSON.stringify(data) !== JSON.stringify(tickerData)) {
        tickerData = data; // Update the local data
        renderTickertape(); // Re-render the tickertape
    }
}

// Render the tickertape with all entries
function renderTickertape() {
    if (!tickertapeElement) {
        console.error("Tickertape element not found!");
        return;
    }

    // Clear existing content
    tickertapeElement.innerHTML = '';

    // Populate tickertape with the latest data
    tickerData.forEach((entry) => {
        const [name, statType, change, source] = entry;
        const text = `${name}: ${statType} ${change} (${source})`;

        // Create a span for the entry with spacing
        const span = document.createElement('span');
        span.textContent = text;
        span.style.marginRight = '50px'; // Spacing between entries
        tickertapeElement.appendChild(span);
    });

    // Append the first entry again at the end to minimize the gap
    if (tickerData.length > 0) {
        const [name, statType, change, source] = tickerData[0];
        const text = `${name}: ${statType} ${change} (${source})`;
        const span = document.createElement('span');
        span.textContent = text;
        span.style.marginRight = '50px'; // Same spacing as other words
        tickertapeElement.appendChild(span);
    }

    // Reset the scroll position to off-screen right
    tickertapeElement.style.transform = `translateX(100%)`;
    startTickertapeScroll();
}

// Smooth scrolling logic
function startTickertapeScroll() {
    const tickertapeWidth = tickertapeElement.scrollWidth;  // Width of the tickertape content
    const containerWidth = tickertapeContainer.offsetWidth; // Width of the container
    let offset = containerWidth; // Start off-screen to the right

    function scroll() {
        tickertapeElement.style.transform = `translateX(${offset}px)`; // Move the text
        offset -= 1; // Adjust speed (lower value = slower scroll)

        if (offset <= -tickertapeWidth) {
            offset = containerWidth; // Reset to the starting position
        }

        requestAnimationFrame(scroll);
    }

    scroll();
}

// Initialize tickertape functionality on page load
document.addEventListener('DOMContentLoaded', () => {
    fetchTickertapeData(); // Fetch the initial data
    setInterval(fetchTickertapeData, 5000); // Check for new data every 5 seconds
});

function setLoading(buttonId, isLoading) {
  console.log(`Setting loading for button ID: ${buttonId}`);
    const button = document.getElementById(buttonId);

    if (!button) {
        console.error(`Button with ID ${buttonId} not found.`);
        return;
    }

    if (isLoading) {
        button.classList.add("loading");
        button.disabled = true;
    } else {
        button.classList.remove("loading");
        button.disabled = false;
    }
}
function showHeal2Container() {
    const container = document.getElementById("heal2-container");
    if (container) container.style.display = "block";
    populateTeammates();
}
function closeHeal2Container() {
    const container = document.getElementById("heal2-container");
    if (container) container.style.display = "none";
}
function showHeal3Container() {
    const container = document.getElementById("heal2-container"); // Reuse heal2-container
    if (container) {
        container.style.display = "block"; // Show the modal
        const heading = container.querySelector("h2");
        heading.textContent = "Heal 3"; // Update heading to "Heal 3"
        const healButton = document.getElementById("healTeammateButton");
        healButton.textContent = "Apply Full Healh"; // Update button text for Heal 3
        healButton.onclick = applyHeal3; // Set the correct onclick handler for Heal 3
    }
    populateTeammates(); // Populate the teammate dropdown
}
function showGuard1Container() {
    const container = document.getElementById("heal2-container"); // Reuse heal2-container
    if (container) {
        container.style.display = "block"; // Show modal
        const heading = container.querySelector("h2");
        heading.textContent = "Guard 1"; // Update heading to "Guard 1"
        const guardButton = document.getElementById("healTeammateButton");
        guardButton.textContent = "Protect Teammate"; // Update button text
        guardButton.onclick = applyGuard1; // Set the correct function for Guard 1
    }
    populateTeammatesNoSelf(); // Populate teammates excluding the Guardian
}
function showGuard2Container() {
    const container = document.getElementById("heal2-container"); // Reuse the heal2-container
    if (container) {
        container.style.display = "block"; // Show modal
        const heading = container.querySelector("h2");
        heading.textContent = "Guard 2"; // Update heading to "Guard 2"
        const guardButton = document.getElementById("healTeammateButton");
        guardButton.textContent = "Give 3 Hearts"; // Update button text
        guardButton.onclick = applyGuard2; // Set the correct function for Guard 2
    }
    populateTeammates(); // Include "Myself" option for self-protection
}
function showReviveContainer() {
    const container = document.getElementById("revive-container"); // Use dedicated revive container
    if (container) {
        container.style.display = "block"; // Show the modal
    }

    populateTeammatesNoSelf("reviveDropdown"); // Populate the dropdown without "Myself"
}


function populateTeammates(dropdownId = "teammateDropdown") {
    google.script.run.withSuccessHandler(teammates => {
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
            console.error(`Dropdown element with ID "${dropdownId}" not found.`);
            return;
        }

        dropdown.innerHTML = ""; // Clear existing options

        // Add "Myself" as the first option
        const selfOption = document.createElement("option");
        selfOption.value = "self";
        selfOption.textContent = "Myself";
        dropdown.appendChild(selfOption);

        if (teammates.length === 0) {
            console.warn("No teammates found for dropdown.");
        }

        // Add teammates to dropdown
        teammates.forEach(teammate => {
            const option = document.createElement("option");
            option.value = teammate.id;
            option.textContent = teammate.name;
            dropdown.appendChild(option);
        });

        console.log(`Dropdown "${dropdownId}" populated with teammates (including self):`, teammates);
    }).getTeammatesForDropdown(storedUniqueId);
}

function populateTeammatesNoSelf(dropdownId = "teammateDropdown") {
    google.script.run.withSuccessHandler(teammates => {
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
            console.error(`Dropdown element with ID "${dropdownId}" not found.`);
            return;
        }

        dropdown.innerHTML = ""; // Clear existing options

        // Exclude the user themselves
        const filteredTeammates = teammates.filter(teammate => teammate.id !== storedUniqueId);

        if (filteredTeammates.length === 0) {
            console.warn("No teammates available to select.");
        }

        filteredTeammates.forEach(teammate => {
            const option = document.createElement("option");
            option.value = teammate.id;
            option.textContent = teammate.name;
            dropdown.appendChild(option);
        });

        console.log(`Dropdown "${dropdownId}" populated with teammates (no self):`, filteredTeammates);
    }).getTeammatesForDropdown(storedUniqueId);
}


function applyHeal2() {
    const teammateId = document.getElementById("teammateDropdown").value;
    const feedbackElement = document.getElementById("heal2Feedback");

    // Clear feedback before starting
    feedbackElement.textContent = "";

    google.script.run
        .withSuccessHandler(message => {
            feedbackElement.textContent = message;

            // Close the Heal 2 container
            const container = document.getElementById("heal2-container");
            if (container) container.style.display = "none";

            // Display the modal with the message after closing the container
            setTimeout(() => {
                showModal(message); // Show the modal after closing Heal 2
            }, 100); // Slight delay for smooth UX
            refreshTable(); // Refresh player data
        })
        .withFailureHandler(error => {
            feedbackElement.textContent = "An error occurred while processing Heal 2.";
            console.error("Error in applyHeal2:", error);

            // Optional: Display modal for error
            showModal("An error occurred while processing Heal 2.");
        })
        .useHeal2Button(storedUniqueId, teammateId || null); // Pass teammate ID or null for self
}
function applyHeal3() {
    const teammateId = document.getElementById("teammateDropdown").value; // Get selected teammate
    const feedbackElement = document.getElementById("heal2Feedback");
    feedbackElement.textContent = ""; // Clear feedback text

    google.script.run
        .withSuccessHandler(message => {
            feedbackElement.textContent = message;
            const container = document.getElementById("heal2-container");
            if (container) container.style.display = "none"; // Close modal

            setTimeout(() => {
                showModal(message); // Display the success message in modal
            }, 100);

            refreshTable(); // Refresh player data
        })
        .withFailureHandler(error => {
            feedbackElement.textContent = "An error occurred while processing Heal 3.";
            console.error("Error in applyHeal3:", error);
            showModal("An error occurred while using Heal 3.");
        })
        .useHeal3Button(storedUniqueId, teammateId || "self"); // Send teammate ID to backend
}
function applyGuard1() {
    const teammateId = document.getElementById("teammateDropdown").value; // Get selected teammate
    const feedbackElement = document.getElementById("heal2Feedback");
    feedbackElement.textContent = ""; // Clear feedback

    google.script.run
        .withSuccessHandler(message => {
            feedbackElement.textContent = message;
            const container = document.getElementById("heal2-container");
            if (container) container.style.display = "none"; // Close modal

            setTimeout(() => {
                showModal(message); // Display success message in modal
            }, 100);

            refreshTable(); // Refresh the table with updated stats
        })
        .withFailureHandler(error => {
            feedbackElement.textContent = "An error occurred while processing Guard 1.";
            console.error("Error in applyGuard1:", error);
            showModal("An error occurred while using Guard 1.");
        })
        .useGuard1Button(storedUniqueId, teammateId || "self"); // Send teammate ID to backend
}
function applyGuard2() {
    const teammateId = document.getElementById("teammateDropdown").value; // Get selected teammate
    const feedbackElement = document.getElementById("heal2Feedback");
    feedbackElement.textContent = ""; // Clear feedback text

    google.script.run
        .withSuccessHandler(message => {
            feedbackElement.textContent = message;
            const container = document.getElementById("heal2-container");
            if (container) container.style.display = "none"; // Close modal

            setTimeout(() => {
                showModal(message); // Display success message in modal
            }, 100);

            refreshTable(); // Refresh player stats
        })
        .withFailureHandler(error => {
            feedbackElement.textContent = "An error occurred while processing Guard 2.";
            console.error("Error in applyGuard2:", error);
            showModal("An error occurred while using Guard 2.");
        })
        .useGuard2Button(storedUniqueId, teammateId || "self"); // Send teammate ID to backend
}
function applyRevive() {
    const teammateId = document.getElementById("reviveDropdown").value;
    const feedbackElement = document.getElementById("reviveFeedback"); // Use correct feedback element
    feedbackElement.textContent = ""; // Clear feedback text

    google.script.run
        .withSuccessHandler(message => {
            feedbackElement.textContent = message;

            if (!message.toLowerCase().includes("revived")) {
                showModal(message); // Show warning or failure message
            } else {
                const container = document.getElementById("revive-container");
                if (container) container.style.display = "none"; // Close on success

                setTimeout(() => {
                    showModal(message); // Show success message
                }, 100);

                refreshTable(); // Refresh UI data
            }
        })
        .withFailureHandler(error => {
            feedbackElement.textContent = "An error occurred while processing Revive.";
            console.error("Error in applyRevive:", error);
            showModal("An error occurred while using Revive.");
        })
        .useReviveButton(storedUniqueId, teammateId);
}


  document.addEventListener("DOMContentLoaded", function () {
    let spriteTriggered = false;

    window.addEventListener("scroll", function () {
      if (!spriteTriggered && window.scrollY > 100) {
        spriteTriggered = true;
        console.log("Player scrolled, triggering sprite check...");

        setTimeout(() => {
          if (Math.random() < 1 / 8) {
            spawnFloatingSprite();
          }
        }, 2000);
      }
    });
  });

  function spawnFloatingSprite() {
    console.log("Floating sprite appearing!");

    const spriteButton = document.createElement("button");
    spriteButton.id = "floatingSpriteButton";
    spriteButton.className = "floating-sprite-button";

    const spriteImage = document.createElement("img");
    spriteImage.src = "https://i.imgur.com/8wSTxQw.png";
    spriteImage.alt = "Floating Sprite";
    spriteButton.appendChild(spriteImage);

    spriteButton.style.top = Math.random() * 80 + "vh";
    document.body.appendChild(spriteButton);

    spriteButton.addEventListener("click", function () {
      spriteButton.remove();
      google.script.run.withSuccessHandler((response) => {
        showModal(response);
      }).logSpriteCatch(storedUniqueId);
    });

    setTimeout(() => spriteButton.remove(), 4000);
  }


  
  function renderExchangeData(data) {
    const today = data[data.length - 1];
    document.getElementById('crystal-rate').innerText = `${today.rate} GP`;
    document.getElementById('market-flavor').innerText = getMarketFlavor(today.rate);

    const ctx = document.getElementById('rateChart').getContext('2d');
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: data.map(d => d.date.slice(5)),
        datasets: [{
          label: 'Crystal Rate',
          data: data.map(d => d.rate),
          borderWidth: 2,
          borderColor: 'blue',
          backgroundColor: 'rgba(0, 0, 255, 0.1)',
          tension: 0.3,
          fill: true,
          pointRadius: 3
        }]
      },
      options: {
        plugins: { legend: { display: false }},
        scales: {
  y: { beginAtZero: false, min: 115, max: 155 }
}
      }
    });
  }

  function getMarketFlavor(rate) {
  if (rate <= 122) return "🚨 Crash! The market is in freefall!";
  if (rate <= 127) return "📉 Prices are low. Might be time to buy!";
  if (rate <= 135) return "⚖️ Market is steady today.";
  if (rate <= 145) return "📈 Crystal prices rising steadily.";
  return "💥 Spike! Crystals are at a premium!";
}
function buyOneCrystal() {
  const button = event.currentTarget;
  button.classList.add('loading');

  google.script.run
    .withSuccessHandler(response => {
      showModal(response);
      refreshTable();
      google.script.run
        .withSuccessHandler(renderCrystalExchangeDisplay)
        .getCrystalExchangeDataForPlayer(storedUniqueId);
      button.classList.remove('loading');
    })
    .withFailureHandler(error => {
      showModal("An error occurred while buying a crystal.");
      console.error("Buy crystal error:", error);
      button.classList.remove('loading');
    })
    .buyOneCrystal(storedUniqueId);
}



function sellOneCrystal() {
  const button = event.currentTarget;
  button.classList.add('loading');

  google.script.run
    .withSuccessHandler(response => {
      showModal(response);
      refreshTable();
      google.script.run
        .withSuccessHandler(renderCrystalExchangeDisplay)
        .getCrystalExchangeDataForPlayer(storedUniqueId);
      button.classList.remove('loading');
    })
    .withFailureHandler(error => {
      showModal("An error occurred while selling a crystal.");
      console.error("Sell crystal error:", error);
      button.classList.remove('loading');
    })
    .sellOneCrystal(storedUniqueId);
}


function cashOutVault() {
  const button = event.currentTarget;
  button.classList.add('loading');

  google.script.run
    .withSuccessHandler(response => {
      showModal(response);
      refreshTable();
      google.script.run
        .withSuccessHandler(renderCrystalExchangeDisplay)
        .getCrystalExchangeDataForPlayer(storedUniqueId);
      button.classList.remove('loading');
    })
    .withFailureHandler(error => {
      showModal("An error occurred while cashing out.");
      console.error("Cash out error:", error);
      button.classList.remove('loading');
    })
    .cashOutVaultedCrystals(storedUniqueId);
}


function renderCrystalExchangeDisplay(data) {
  console.log("🎯 FINAL Crystal Exchange Data Received:", data);
  console.log("🔍 Crystal Exchange Data:", data);
  console.log("📊 renderCrystalExchangeDisplay called");
  console.log("🧪 Data received:", data);
  if (!data || !data.rates || !data.rates.length) {
    console.warn("Crystal Exchange data missing or empty.");
    console.log("🎯 FINAL Crystal Exchange Data Received:", data);
    console.trace(); // 🔍 Shows where this call is coming from
    if (exchangeLoaded) return; // prevent duplicate renders
exchangeLoaded = true;
    return;
  }

  const today = data.rates[data.rates.length - 1];
  document.getElementById("crystal-rate").innerText = `${today.rate.toFixed(2)} GP`;
  document.getElementById("vault-count").innerText = `${data.vault} Crystals`;
  document.getElementById("market-flavor").innerText = getMarketFlavor(today.rate);

  const ctx = document.getElementById("rateChart").getContext("2d");
  new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.rates.map(d => {
  const dateObj = new Date(d.date);
  return `${dateObj.getMonth() + 1}/${dateObj.getDate()}`;
}),
      datasets: [{
        label: 'Crystal Rate',
        data: data.rates.map(d => d.rate),
        borderWidth: 2,
        borderColor: 'blue',
        backgroundColor: 'rgba(0, 0, 255, 0.1)',
        tension: 0.3,
        fill: true,
        pointRadius: 3
      }]
    },
    options: {
      plugins: { legend: { display: false }},
      scales: {
        y: { beginAtZero: false, min: 115, max: 155 }
      }
    }
  });
}


</script>
</body>
</html>
